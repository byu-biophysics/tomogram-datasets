{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"tomogram_datasets Welcome to the documentation for the tomogram_datasets module. This module simplifies tasks dealing with tomograms and their respective annotations.","title":"tomogram_datasets"},{"location":"#tomogram_datasets","text":"Welcome to the documentation for the tomogram_datasets module. This module simplifies tasks dealing with tomograms and their respective annotations.","title":"tomogram_datasets"},{"location":"annotation/","text":"This module provides classes to work with tomogram annotations. Annotation This class represents a tomogram annotation. Attributes: points ( list of numpy.ndarray ) \u2013 Annnotation points name ( str ) \u2013 Name of this annotation Source code in tomogram_datasets/annotation.py 17 18 19 20 21 22 23 24 25 26 class Annotation : \"\"\"This class represents a tomogram annotation. Attributes: points (list of numpy.ndarray): Annnotation points name (str): Name of this annotation \"\"\" def __init__ ( self , points : List [ np . ndarray ], name : Optional [ str ] = None ): self . points = points self . name = \"\" if name is None else name AnnotationFile Bases: Annotation This class represents an annotation file. Extends the Annotation class to handle file operations, especially for .mod files. Attributes: filepath ( str ) \u2013 Filepath of this annotation file extension ( str ) \u2013 File extension of this annotation file df ( DataFrame ) \u2013 DataFrame of this file Source code in tomogram_datasets/annotation.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 class AnnotationFile ( Annotation ): \"\"\"This class represents an annotation file. Extends the Annotation class to handle file operations, especially for .mod files. Attributes: filepath (str): Filepath of this annotation file extension (str): File extension of this annotation file df (pandas.DataFrame): DataFrame of this file \"\"\" def __init__ ( self , filepath : str , name : Optional [ str ] = None ): \"\"\"Initializes an AnnotationFile with a .mod file. Args: filepath (str): The filepath of the annotation to load name (str): The name of this annotation Raises: IOError: If the file extension is not .mod or .ndjson. \"\"\" self . filepath = filepath _ , extension = os . path . splitext ( filepath ) self . extension = extension if self . extension == \".mod\" : points = AnnotationFile . mod_points ( self . filepath ) elif self . extension == \".ndjson\" : points = AnnotationFile . ndjson_points ( self . filepath ) super () . __init__ ( points , name ) @staticmethod def check_ext ( filepath : str , ext : str ): \"\"\"Ensures that filepath is of a given type. Args: filepath (str): The file to check. ext (str): The desired file extension, i.e., \".mod\". Raises: IOError: If the file extension is not `ext`. \"\"\" _ , extension = os . path . splitext ( filepath ) if extension != ext : raise IOError ( f \"Annotation must be a { ext } file.\" ) @staticmethod def mod_to_pd ( filepath : str ) -> pd . DataFrame : \"\"\"Converts a .mod file to a pandas DataFrame. Args: filepath (str): File to convert. Returns: DataFrame of the annotation file with center_x, center_y, center_z renamed to x, y, z if annotation='slicer_angles'. Raises: IOError: If the file extension is not .mod. \"\"\" AnnotationFile . check_ext ( filepath , \".mod\" ) try : # First attempt with the 'annotation' parameter df = imodmodel . read ( filepath , annotation = 'slicer_angles' ) # Check if the relevant columns are present and rename them if all ( col in df . columns for col in [ 'center_x' , 'center_y' , 'center_z' ]): df = df . rename ( columns = { 'center_x' : 'x' , 'center_y' : 'y' , 'center_z' : 'z' }) return df except Exception as e : print ( f \"Attempt with 'annotation=slicer_angles' failed: { e } \" ) # Fallback attempt without the 'annotation' parameter return imodmodel . read ( filepath ) @staticmethod def mod_points ( filepath : str ) -> List [ np . ndarray ]: \"\"\"Reads a .mod file and extracts the points it contains. Args: filepath (str) Returns: List of points in the annotation file. \"\"\" df = AnnotationFile . mod_to_pd ( filepath ) points = [] for _ , row in df . iterrows (): # Assumes point is 3D dim_labels = [ 'x' , 'y' , 'z' ] point = np . array ([ row [ dim ] for dim in dim_labels ]) # The annotations seem to have been stored with this indexing. dims_order = [ 2 , 1 , 0 ] points . append ( point [ dims_order ]) return points @staticmethod def ndjson_points ( filepath : str ) -> List [ np . ndarray ]: \"\"\"Reads a .ndjson annotation file as stored on the CryoET Data Portal and extracts the points it contains. Args: filepath (str) Returns: List of points in the annotation file. \"\"\" points = [] with open ( filepath , 'r' ) as file : for line in file : data = json . loads ( line ) if data . get ( \"type\" ) == \"orientedPoint\" : location = data . get ( \"location\" ) if location : point = np . array ([ location [ \"z\" ], location [ \"x\" ], location [ \"y\" ]]) points . append ( point ) return points def tomogram_shape_from_mod ( self ): \"\"\" Finds the shape of the parent tomogram of this annotation, if this annotation is a `.mod` file. Returns: Shape of the parent tomogram. Raises: IOError: If this annotation is not a .mod file. \"\"\" AnnotationFile . check_ext ( self . filepath , \".mod\" ) header = ImodModel . from_file ( self . filepath ) . header return np . array ([ header . zmax , header . xmax , header . ymax ]) __init__ ( filepath , name = None ) Initializes an AnnotationFile with a .mod file. Parameters: filepath ( str ) \u2013 The filepath of the annotation to load name ( str , default: None ) \u2013 The name of this annotation Raises: IOError \u2013 If the file extension is not .mod or .ndjson. Source code in tomogram_datasets/annotation.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , filepath : str , name : Optional [ str ] = None ): \"\"\"Initializes an AnnotationFile with a .mod file. Args: filepath (str): The filepath of the annotation to load name (str): The name of this annotation Raises: IOError: If the file extension is not .mod or .ndjson. \"\"\" self . filepath = filepath _ , extension = os . path . splitext ( filepath ) self . extension = extension if self . extension == \".mod\" : points = AnnotationFile . mod_points ( self . filepath ) elif self . extension == \".ndjson\" : points = AnnotationFile . ndjson_points ( self . filepath ) super () . __init__ ( points , name ) check_ext ( filepath , ext ) staticmethod Ensures that filepath is of a given type. Parameters: filepath ( str ) \u2013 The file to check. ext ( str ) \u2013 The desired file extension, i.e., \".mod\". Raises: IOError \u2013 If the file extension is not ext . Source code in tomogram_datasets/annotation.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @staticmethod def check_ext ( filepath : str , ext : str ): \"\"\"Ensures that filepath is of a given type. Args: filepath (str): The file to check. ext (str): The desired file extension, i.e., \".mod\". Raises: IOError: If the file extension is not `ext`. \"\"\" _ , extension = os . path . splitext ( filepath ) if extension != ext : raise IOError ( f \"Annotation must be a { ext } file.\" ) mod_points ( filepath ) staticmethod Reads a .mod file and extracts the points it contains. Returns: List [ ndarray ] \u2013 List of points in the annotation file. Source code in tomogram_datasets/annotation.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 @staticmethod def mod_points ( filepath : str ) -> List [ np . ndarray ]: \"\"\"Reads a .mod file and extracts the points it contains. Args: filepath (str) Returns: List of points in the annotation file. \"\"\" df = AnnotationFile . mod_to_pd ( filepath ) points = [] for _ , row in df . iterrows (): # Assumes point is 3D dim_labels = [ 'x' , 'y' , 'z' ] point = np . array ([ row [ dim ] for dim in dim_labels ]) # The annotations seem to have been stored with this indexing. dims_order = [ 2 , 1 , 0 ] points . append ( point [ dims_order ]) return points mod_to_pd ( filepath ) staticmethod Converts a .mod file to a pandas DataFrame. Parameters: filepath ( str ) \u2013 File to convert. Returns: DataFrame \u2013 DataFrame of the annotation file with center_x, center_y, center_z renamed to DataFrame \u2013 x, y, z if annotation='slicer_angles'. Raises: IOError \u2013 If the file extension is not .mod. Source code in tomogram_datasets/annotation.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 @staticmethod def mod_to_pd ( filepath : str ) -> pd . DataFrame : \"\"\"Converts a .mod file to a pandas DataFrame. Args: filepath (str): File to convert. Returns: DataFrame of the annotation file with center_x, center_y, center_z renamed to x, y, z if annotation='slicer_angles'. Raises: IOError: If the file extension is not .mod. \"\"\" AnnotationFile . check_ext ( filepath , \".mod\" ) try : # First attempt with the 'annotation' parameter df = imodmodel . read ( filepath , annotation = 'slicer_angles' ) # Check if the relevant columns are present and rename them if all ( col in df . columns for col in [ 'center_x' , 'center_y' , 'center_z' ]): df = df . rename ( columns = { 'center_x' : 'x' , 'center_y' : 'y' , 'center_z' : 'z' }) return df except Exception as e : print ( f \"Attempt with 'annotation=slicer_angles' failed: { e } \" ) # Fallback attempt without the 'annotation' parameter return imodmodel . read ( filepath ) ndjson_points ( filepath ) staticmethod Reads a .ndjson annotation file as stored on the CryoET Data Portal and extracts the points it contains. Returns: List [ ndarray ] \u2013 List of points in the annotation file. Source code in tomogram_datasets/annotation.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 @staticmethod def ndjson_points ( filepath : str ) -> List [ np . ndarray ]: \"\"\"Reads a .ndjson annotation file as stored on the CryoET Data Portal and extracts the points it contains. Args: filepath (str) Returns: List of points in the annotation file. \"\"\" points = [] with open ( filepath , 'r' ) as file : for line in file : data = json . loads ( line ) if data . get ( \"type\" ) == \"orientedPoint\" : location = data . get ( \"location\" ) if location : point = np . array ([ location [ \"z\" ], location [ \"x\" ], location [ \"y\" ]]) points . append ( point ) return points tomogram_shape_from_mod () Finds the shape of the parent tomogram of this annotation, if this annotation is a .mod file. Returns: \u2013 Shape of the parent tomogram. Raises: IOError \u2013 If this annotation is not a .mod file. Source code in tomogram_datasets/annotation.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def tomogram_shape_from_mod ( self ): \"\"\" Finds the shape of the parent tomogram of this annotation, if this annotation is a `.mod` file. Returns: Shape of the parent tomogram. Raises: IOError: If this annotation is not a .mod file. \"\"\" AnnotationFile . check_ext ( self . filepath , \".mod\" ) header = ImodModel . from_file ( self . filepath ) . header return np . array ([ header . zmax , header . xmax , header . ymax ])","title":"Annotation"},{"location":"annotation/#tomogram_datasets.annotation.Annotation","text":"This class represents a tomogram annotation. Attributes: points ( list of numpy.ndarray ) \u2013 Annnotation points name ( str ) \u2013 Name of this annotation Source code in tomogram_datasets/annotation.py 17 18 19 20 21 22 23 24 25 26 class Annotation : \"\"\"This class represents a tomogram annotation. Attributes: points (list of numpy.ndarray): Annnotation points name (str): Name of this annotation \"\"\" def __init__ ( self , points : List [ np . ndarray ], name : Optional [ str ] = None ): self . points = points self . name = \"\" if name is None else name","title":"Annotation"},{"location":"annotation/#tomogram_datasets.annotation.AnnotationFile","text":"Bases: Annotation This class represents an annotation file. Extends the Annotation class to handle file operations, especially for .mod files. Attributes: filepath ( str ) \u2013 Filepath of this annotation file extension ( str ) \u2013 File extension of this annotation file df ( DataFrame ) \u2013 DataFrame of this file Source code in tomogram_datasets/annotation.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 class AnnotationFile ( Annotation ): \"\"\"This class represents an annotation file. Extends the Annotation class to handle file operations, especially for .mod files. Attributes: filepath (str): Filepath of this annotation file extension (str): File extension of this annotation file df (pandas.DataFrame): DataFrame of this file \"\"\" def __init__ ( self , filepath : str , name : Optional [ str ] = None ): \"\"\"Initializes an AnnotationFile with a .mod file. Args: filepath (str): The filepath of the annotation to load name (str): The name of this annotation Raises: IOError: If the file extension is not .mod or .ndjson. \"\"\" self . filepath = filepath _ , extension = os . path . splitext ( filepath ) self . extension = extension if self . extension == \".mod\" : points = AnnotationFile . mod_points ( self . filepath ) elif self . extension == \".ndjson\" : points = AnnotationFile . ndjson_points ( self . filepath ) super () . __init__ ( points , name ) @staticmethod def check_ext ( filepath : str , ext : str ): \"\"\"Ensures that filepath is of a given type. Args: filepath (str): The file to check. ext (str): The desired file extension, i.e., \".mod\". Raises: IOError: If the file extension is not `ext`. \"\"\" _ , extension = os . path . splitext ( filepath ) if extension != ext : raise IOError ( f \"Annotation must be a { ext } file.\" ) @staticmethod def mod_to_pd ( filepath : str ) -> pd . DataFrame : \"\"\"Converts a .mod file to a pandas DataFrame. Args: filepath (str): File to convert. Returns: DataFrame of the annotation file with center_x, center_y, center_z renamed to x, y, z if annotation='slicer_angles'. Raises: IOError: If the file extension is not .mod. \"\"\" AnnotationFile . check_ext ( filepath , \".mod\" ) try : # First attempt with the 'annotation' parameter df = imodmodel . read ( filepath , annotation = 'slicer_angles' ) # Check if the relevant columns are present and rename them if all ( col in df . columns for col in [ 'center_x' , 'center_y' , 'center_z' ]): df = df . rename ( columns = { 'center_x' : 'x' , 'center_y' : 'y' , 'center_z' : 'z' }) return df except Exception as e : print ( f \"Attempt with 'annotation=slicer_angles' failed: { e } \" ) # Fallback attempt without the 'annotation' parameter return imodmodel . read ( filepath ) @staticmethod def mod_points ( filepath : str ) -> List [ np . ndarray ]: \"\"\"Reads a .mod file and extracts the points it contains. Args: filepath (str) Returns: List of points in the annotation file. \"\"\" df = AnnotationFile . mod_to_pd ( filepath ) points = [] for _ , row in df . iterrows (): # Assumes point is 3D dim_labels = [ 'x' , 'y' , 'z' ] point = np . array ([ row [ dim ] for dim in dim_labels ]) # The annotations seem to have been stored with this indexing. dims_order = [ 2 , 1 , 0 ] points . append ( point [ dims_order ]) return points @staticmethod def ndjson_points ( filepath : str ) -> List [ np . ndarray ]: \"\"\"Reads a .ndjson annotation file as stored on the CryoET Data Portal and extracts the points it contains. Args: filepath (str) Returns: List of points in the annotation file. \"\"\" points = [] with open ( filepath , 'r' ) as file : for line in file : data = json . loads ( line ) if data . get ( \"type\" ) == \"orientedPoint\" : location = data . get ( \"location\" ) if location : point = np . array ([ location [ \"z\" ], location [ \"x\" ], location [ \"y\" ]]) points . append ( point ) return points def tomogram_shape_from_mod ( self ): \"\"\" Finds the shape of the parent tomogram of this annotation, if this annotation is a `.mod` file. Returns: Shape of the parent tomogram. Raises: IOError: If this annotation is not a .mod file. \"\"\" AnnotationFile . check_ext ( self . filepath , \".mod\" ) header = ImodModel . from_file ( self . filepath ) . header return np . array ([ header . zmax , header . xmax , header . ymax ])","title":"AnnotationFile"},{"location":"annotation/#tomogram_datasets.annotation.AnnotationFile.__init__","text":"Initializes an AnnotationFile with a .mod file. Parameters: filepath ( str ) \u2013 The filepath of the annotation to load name ( str , default: None ) \u2013 The name of this annotation Raises: IOError \u2013 If the file extension is not .mod or .ndjson. Source code in tomogram_datasets/annotation.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , filepath : str , name : Optional [ str ] = None ): \"\"\"Initializes an AnnotationFile with a .mod file. Args: filepath (str): The filepath of the annotation to load name (str): The name of this annotation Raises: IOError: If the file extension is not .mod or .ndjson. \"\"\" self . filepath = filepath _ , extension = os . path . splitext ( filepath ) self . extension = extension if self . extension == \".mod\" : points = AnnotationFile . mod_points ( self . filepath ) elif self . extension == \".ndjson\" : points = AnnotationFile . ndjson_points ( self . filepath ) super () . __init__ ( points , name )","title":"__init__"},{"location":"annotation/#tomogram_datasets.annotation.AnnotationFile.check_ext","text":"Ensures that filepath is of a given type. Parameters: filepath ( str ) \u2013 The file to check. ext ( str ) \u2013 The desired file extension, i.e., \".mod\". Raises: IOError \u2013 If the file extension is not ext . Source code in tomogram_datasets/annotation.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @staticmethod def check_ext ( filepath : str , ext : str ): \"\"\"Ensures that filepath is of a given type. Args: filepath (str): The file to check. ext (str): The desired file extension, i.e., \".mod\". Raises: IOError: If the file extension is not `ext`. \"\"\" _ , extension = os . path . splitext ( filepath ) if extension != ext : raise IOError ( f \"Annotation must be a { ext } file.\" )","title":"check_ext"},{"location":"annotation/#tomogram_datasets.annotation.AnnotationFile.mod_points","text":"Reads a .mod file and extracts the points it contains. Returns: List [ ndarray ] \u2013 List of points in the annotation file. Source code in tomogram_datasets/annotation.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 @staticmethod def mod_points ( filepath : str ) -> List [ np . ndarray ]: \"\"\"Reads a .mod file and extracts the points it contains. Args: filepath (str) Returns: List of points in the annotation file. \"\"\" df = AnnotationFile . mod_to_pd ( filepath ) points = [] for _ , row in df . iterrows (): # Assumes point is 3D dim_labels = [ 'x' , 'y' , 'z' ] point = np . array ([ row [ dim ] for dim in dim_labels ]) # The annotations seem to have been stored with this indexing. dims_order = [ 2 , 1 , 0 ] points . append ( point [ dims_order ]) return points","title":"mod_points"},{"location":"annotation/#tomogram_datasets.annotation.AnnotationFile.mod_to_pd","text":"Converts a .mod file to a pandas DataFrame. Parameters: filepath ( str ) \u2013 File to convert. Returns: DataFrame \u2013 DataFrame of the annotation file with center_x, center_y, center_z renamed to DataFrame \u2013 x, y, z if annotation='slicer_angles'. Raises: IOError \u2013 If the file extension is not .mod. Source code in tomogram_datasets/annotation.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 @staticmethod def mod_to_pd ( filepath : str ) -> pd . DataFrame : \"\"\"Converts a .mod file to a pandas DataFrame. Args: filepath (str): File to convert. Returns: DataFrame of the annotation file with center_x, center_y, center_z renamed to x, y, z if annotation='slicer_angles'. Raises: IOError: If the file extension is not .mod. \"\"\" AnnotationFile . check_ext ( filepath , \".mod\" ) try : # First attempt with the 'annotation' parameter df = imodmodel . read ( filepath , annotation = 'slicer_angles' ) # Check if the relevant columns are present and rename them if all ( col in df . columns for col in [ 'center_x' , 'center_y' , 'center_z' ]): df = df . rename ( columns = { 'center_x' : 'x' , 'center_y' : 'y' , 'center_z' : 'z' }) return df except Exception as e : print ( f \"Attempt with 'annotation=slicer_angles' failed: { e } \" ) # Fallback attempt without the 'annotation' parameter return imodmodel . read ( filepath )","title":"mod_to_pd"},{"location":"annotation/#tomogram_datasets.annotation.AnnotationFile.ndjson_points","text":"Reads a .ndjson annotation file as stored on the CryoET Data Portal and extracts the points it contains. Returns: List [ ndarray ] \u2013 List of points in the annotation file. Source code in tomogram_datasets/annotation.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 @staticmethod def ndjson_points ( filepath : str ) -> List [ np . ndarray ]: \"\"\"Reads a .ndjson annotation file as stored on the CryoET Data Portal and extracts the points it contains. Args: filepath (str) Returns: List of points in the annotation file. \"\"\" points = [] with open ( filepath , 'r' ) as file : for line in file : data = json . loads ( line ) if data . get ( \"type\" ) == \"orientedPoint\" : location = data . get ( \"location\" ) if location : point = np . array ([ location [ \"z\" ], location [ \"x\" ], location [ \"y\" ]]) points . append ( point ) return points","title":"ndjson_points"},{"location":"annotation/#tomogram_datasets.annotation.AnnotationFile.tomogram_shape_from_mod","text":"Finds the shape of the parent tomogram of this annotation, if this annotation is a .mod file. Returns: \u2013 Shape of the parent tomogram. Raises: IOError \u2013 If this annotation is not a .mod file. Source code in tomogram_datasets/annotation.py 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def tomogram_shape_from_mod ( self ): \"\"\" Finds the shape of the parent tomogram of this annotation, if this annotation is a `.mod` file. Returns: Shape of the parent tomogram. Raises: IOError: If this annotation is not a .mod file. \"\"\" AnnotationFile . check_ext ( self . filepath , \".mod\" ) header = ImodModel . from_file ( self . filepath ) . header return np . array ([ header . zmax , header . xmax , header . ymax ])","title":"tomogram_shape_from_mod"},{"location":"subtomogram/","text":"Subtomogram Bases: Tomogram A class representing a subtomogram extracted from a parent tomogram. Attributes: parent_tomogram ( Tomogram ) \u2013 The tomogram from which this subtomogram was lower_bounds ( ndarray ) \u2013 The lower bounds of the subtomogram as they data ( ndarray ) \u2013 The 3D data of the subtomogram. shape ( ndarray ) \u2013 The shape of the subtomogram. Source code in tomogram_datasets/subtomogram.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class Subtomogram ( Tomogram ): \"\"\" A class representing a subtomogram extracted from a parent tomogram. Attributes: parent_tomogram (Tomogram): The tomogram from which this subtomogram was created. lower_bounds (np.ndarray): The lower bounds of the subtomogram as they would be indexed in the parent tomogram. data (np.ndarray): The 3D data of the subtomogram. shape (np.ndarray): The shape of the subtomogram. \"\"\" def __init__ ( self , parent_tomogram : 'Tomogram' , lower_bounds : np . ndarray , shape : np . ndarray ) -> None : \"\"\" Initializes a Subtomogram instance. Args: parent_tomogram (Tomogram): The parent tomogram. lower_bounds (np.ndarray): The lower bounds for the subtomogram. shape (np.ndarray): The shape of the subtomogram. \"\"\" self . parent_tomogram = parent_tomogram self . lower_bounds = lower_bounds # Modify annotations from the parent tomogram to match this tomogram new_annotations : List [ Annotation ] = [] for parent_annotation in self . parent_tomogram . annotations : new_points : List [ np . ndarray ] = [] # Offset original points for this new subtomogram for point in parent_annotation . points : new_point = point - lower_bounds # Check if new_point is even in the new tomogram if _in_bounds ( shape , new_point ): new_points . append ( new_point ) # Otherwise continue # Add the annotation only if there are points in it if len ( new_points ) > 0 : new_annotations . append ( Annotation ( new_points , parent_annotation . name )) # Get subvolume data using lower bounds and shape min_0 , min_1 , min_2 = lower_bounds shape_0 , shape_1 , shape_2 = shape new_data = parent_tomogram . data [ min_0 : min_0 + shape_0 , min_1 : min_1 + shape_1 , min_2 : min_2 + shape_2 ] # Initialize this new Tomogram super () . __init__ ( new_data , new_annotations ) __init__ ( parent_tomogram , lower_bounds , shape ) Initializes a Subtomogram instance. Parameters: parent_tomogram ( Tomogram ) \u2013 The parent tomogram. lower_bounds ( ndarray ) \u2013 The lower bounds for the subtomogram. shape ( ndarray ) \u2013 The shape of the subtomogram. Source code in tomogram_datasets/subtomogram.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , parent_tomogram : 'Tomogram' , lower_bounds : np . ndarray , shape : np . ndarray ) -> None : \"\"\" Initializes a Subtomogram instance. Args: parent_tomogram (Tomogram): The parent tomogram. lower_bounds (np.ndarray): The lower bounds for the subtomogram. shape (np.ndarray): The shape of the subtomogram. \"\"\" self . parent_tomogram = parent_tomogram self . lower_bounds = lower_bounds # Modify annotations from the parent tomogram to match this tomogram new_annotations : List [ Annotation ] = [] for parent_annotation in self . parent_tomogram . annotations : new_points : List [ np . ndarray ] = [] # Offset original points for this new subtomogram for point in parent_annotation . points : new_point = point - lower_bounds # Check if new_point is even in the new tomogram if _in_bounds ( shape , new_point ): new_points . append ( new_point ) # Otherwise continue # Add the annotation only if there are points in it if len ( new_points ) > 0 : new_annotations . append ( Annotation ( new_points , parent_annotation . name )) # Get subvolume data using lower bounds and shape min_0 , min_1 , min_2 = lower_bounds shape_0 , shape_1 , shape_2 = shape new_data = parent_tomogram . data [ min_0 : min_0 + shape_0 , min_1 : min_1 + shape_1 , min_2 : min_2 + shape_2 ] # Initialize this new Tomogram super () . __init__ ( new_data , new_annotations ) SubtomogramGenerator A class for generating subtomograms from a parent tomogram. Attributes: tomogram ( Tomogram ) \u2013 The parent tomogram to sample from. annotations ( List [ Annotation ] ) \u2013 The annotations from the parent vol_shape ( Tuple [ int , int , int ] ) \u2013 The shape of the volumes to be pads ( Tuple [ int , int , int ] ) \u2013 The padding to apply to the boundaries. gen ( Generator ) \u2013 Random number generator for sampling. Source code in tomogram_datasets/subtomogram.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class SubtomogramGenerator : \"\"\" A class for generating subtomograms from a parent tomogram. Attributes: tomogram (Tomogram): The parent tomogram to sample from. annotations (List[Annotation]): The annotations from the parent tomogram. vol_shape (Tuple[int, int, int]): The shape of the volumes to be generated. pads (Tuple[int, int, int]): The padding to apply to the boundaries. gen (np.random.Generator): Random number generator for sampling. \"\"\" def __init__ ( self , tomogram : 'Tomogram' ) -> None : \"\"\" Initializes a SubtomogramGenerator instance. Args: tomogram (Tomogram): The parent tomogram to sample from. \"\"\" self . tomogram = tomogram self . tomogram . load () self . annotations = self . tomogram . annotations self . vol_shape = ( 64 , 256 , 256 ) self . pads = ( 8 , 32 , 32 ) self . gen = np . random . default_rng () def set_vol_shape ( self , new_vol_shape : tuple [ int , int , int ]): \"\"\" Sets a new volume shape for the generator. Args: new_vol_shape (tuple[int, int, int]): The new volume shape. \"\"\" self . vol_shape = new_vol_shape def positive_sample ( self , point : Optional [ np . ndarray ] = None ) -> Subtomogram : \"\"\" Returns a random subtomogram containing the specified point. The point will not be closer than `pads` voxels to the respective borders. If no point is given, a random annotation point from self.tomogram's annotations is selected. Args: point (Optional[np.ndarray]): The point to include in the subtomogram. Defaults to None. Returns: The newly created subtomogram. \"\"\" if point is None : # Pick a random annotation point from self.tomogram's annotations annotation = self . gen . choice ( self . annotations ) point = self . gen . choice ( annotation . points ) possible_lower_bounds = [ np . linspace ( max ( 0 , pt - vs + pad ), min ( ts - vs , pt - pad ), endpoint = False , dtype = int ) for ( ts , vs , pt , pad ) in zip ( self . tomogram . shape , self . vol_shape , point , self . pads )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Construct a new Tomogram with modified annotations return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape ) def negative_sample ( self ) -> Subtomogram : \"\"\" Returns a random subtomogram that does not contain any points from the annotations. This process continues until a valid subtomogram is found or the maximum iterations are reached. Returns: The newly created subtomogram. Raises: Exception: If unable to find a valid subtomogram without annotation points after 1000 attempts. \"\"\" # Generate completely random bounds until one has no annotations maxiter = 1000 for iter in range ( maxiter ): possible_lower_bounds = [ np . linspace ( 0 , ts - vs , endpoint = False , dtype = int ) for ( ts , vs ) in zip ( self . tomogram . shape , self . vol_shape )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Check if this volume contains any annotation points contains_annotation = False for point in self . tomogram . annotation_points (): new_point = point - lower_bounds if _in_bounds ( self . vol_shape , new_point ): contains_annotation = True break if not contains_annotation : return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape ) raise Exception ( \"Failed to find a volume without an annotation\" ) def find_annotation_points ( self ) -> List [ np . ndarray ]: \"\"\" Returns a list of points that are present in the annotations. Returns: A list of annotation points. \"\"\" points : List [ np . ndarray ] = [] for annotation in self . annotations : points += annotation . points return points __init__ ( tomogram ) Initializes a SubtomogramGenerator instance. Parameters: tomogram ( Tomogram ) \u2013 The parent tomogram to sample from. Source code in tomogram_datasets/subtomogram.py 104 105 106 107 108 109 110 111 112 113 114 115 116 def __init__ ( self , tomogram : 'Tomogram' ) -> None : \"\"\" Initializes a SubtomogramGenerator instance. Args: tomogram (Tomogram): The parent tomogram to sample from. \"\"\" self . tomogram = tomogram self . tomogram . load () self . annotations = self . tomogram . annotations self . vol_shape = ( 64 , 256 , 256 ) self . pads = ( 8 , 32 , 32 ) self . gen = np . random . default_rng () find_annotation_points () Returns a list of points that are present in the annotations. Returns: List [ ndarray ] \u2013 A list of annotation points. Source code in tomogram_datasets/subtomogram.py 202 203 204 205 206 207 208 209 210 211 212 def find_annotation_points ( self ) -> List [ np . ndarray ]: \"\"\" Returns a list of points that are present in the annotations. Returns: A list of annotation points. \"\"\" points : List [ np . ndarray ] = [] for annotation in self . annotations : points += annotation . points return points negative_sample () Returns a random subtomogram that does not contain any points from the annotations. This process continues until a valid subtomogram is found or the maximum iterations are reached. Returns: Subtomogram \u2013 The newly created subtomogram. Raises: Exception \u2013 If unable to find a valid subtomogram without annotation Source code in tomogram_datasets/subtomogram.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def negative_sample ( self ) -> Subtomogram : \"\"\" Returns a random subtomogram that does not contain any points from the annotations. This process continues until a valid subtomogram is found or the maximum iterations are reached. Returns: The newly created subtomogram. Raises: Exception: If unable to find a valid subtomogram without annotation points after 1000 attempts. \"\"\" # Generate completely random bounds until one has no annotations maxiter = 1000 for iter in range ( maxiter ): possible_lower_bounds = [ np . linspace ( 0 , ts - vs , endpoint = False , dtype = int ) for ( ts , vs ) in zip ( self . tomogram . shape , self . vol_shape )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Check if this volume contains any annotation points contains_annotation = False for point in self . tomogram . annotation_points (): new_point = point - lower_bounds if _in_bounds ( self . vol_shape , new_point ): contains_annotation = True break if not contains_annotation : return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape ) raise Exception ( \"Failed to find a volume without an annotation\" ) positive_sample ( point = None ) Returns a random subtomogram containing the specified point. The point will not be closer than pads voxels to the respective borders. If no point is given, a random annotation point from self.tomogram's annotations is selected. Parameters: point ( Optional [ ndarray ] , default: None ) \u2013 The point to include in the Returns: Subtomogram \u2013 The newly created subtomogram. Source code in tomogram_datasets/subtomogram.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def positive_sample ( self , point : Optional [ np . ndarray ] = None ) -> Subtomogram : \"\"\" Returns a random subtomogram containing the specified point. The point will not be closer than `pads` voxels to the respective borders. If no point is given, a random annotation point from self.tomogram's annotations is selected. Args: point (Optional[np.ndarray]): The point to include in the subtomogram. Defaults to None. Returns: The newly created subtomogram. \"\"\" if point is None : # Pick a random annotation point from self.tomogram's annotations annotation = self . gen . choice ( self . annotations ) point = self . gen . choice ( annotation . points ) possible_lower_bounds = [ np . linspace ( max ( 0 , pt - vs + pad ), min ( ts - vs , pt - pad ), endpoint = False , dtype = int ) for ( ts , vs , pt , pad ) in zip ( self . tomogram . shape , self . vol_shape , point , self . pads )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Construct a new Tomogram with modified annotations return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape ) set_vol_shape ( new_vol_shape ) Sets a new volume shape for the generator. Parameters: new_vol_shape ( tuple [ int , int , int ] ) \u2013 The new volume shape. Source code in tomogram_datasets/subtomogram.py 118 119 120 121 122 123 124 125 def set_vol_shape ( self , new_vol_shape : tuple [ int , int , int ]): \"\"\" Sets a new volume shape for the generator. Args: new_vol_shape (tuple[int, int, int]): The new volume shape. \"\"\" self . vol_shape = new_vol_shape","title":"Subtomogram"},{"location":"subtomogram/#tomogram_datasets.subtomogram.Subtomogram","text":"Bases: Tomogram A class representing a subtomogram extracted from a parent tomogram. Attributes: parent_tomogram ( Tomogram ) \u2013 The tomogram from which this subtomogram was lower_bounds ( ndarray ) \u2013 The lower bounds of the subtomogram as they data ( ndarray ) \u2013 The 3D data of the subtomogram. shape ( ndarray ) \u2013 The shape of the subtomogram. Source code in tomogram_datasets/subtomogram.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class Subtomogram ( Tomogram ): \"\"\" A class representing a subtomogram extracted from a parent tomogram. Attributes: parent_tomogram (Tomogram): The tomogram from which this subtomogram was created. lower_bounds (np.ndarray): The lower bounds of the subtomogram as they would be indexed in the parent tomogram. data (np.ndarray): The 3D data of the subtomogram. shape (np.ndarray): The shape of the subtomogram. \"\"\" def __init__ ( self , parent_tomogram : 'Tomogram' , lower_bounds : np . ndarray , shape : np . ndarray ) -> None : \"\"\" Initializes a Subtomogram instance. Args: parent_tomogram (Tomogram): The parent tomogram. lower_bounds (np.ndarray): The lower bounds for the subtomogram. shape (np.ndarray): The shape of the subtomogram. \"\"\" self . parent_tomogram = parent_tomogram self . lower_bounds = lower_bounds # Modify annotations from the parent tomogram to match this tomogram new_annotations : List [ Annotation ] = [] for parent_annotation in self . parent_tomogram . annotations : new_points : List [ np . ndarray ] = [] # Offset original points for this new subtomogram for point in parent_annotation . points : new_point = point - lower_bounds # Check if new_point is even in the new tomogram if _in_bounds ( shape , new_point ): new_points . append ( new_point ) # Otherwise continue # Add the annotation only if there are points in it if len ( new_points ) > 0 : new_annotations . append ( Annotation ( new_points , parent_annotation . name )) # Get subvolume data using lower bounds and shape min_0 , min_1 , min_2 = lower_bounds shape_0 , shape_1 , shape_2 = shape new_data = parent_tomogram . data [ min_0 : min_0 + shape_0 , min_1 : min_1 + shape_1 , min_2 : min_2 + shape_2 ] # Initialize this new Tomogram super () . __init__ ( new_data , new_annotations )","title":"Subtomogram"},{"location":"subtomogram/#tomogram_datasets.subtomogram.Subtomogram.__init__","text":"Initializes a Subtomogram instance. Parameters: parent_tomogram ( Tomogram ) \u2013 The parent tomogram. lower_bounds ( ndarray ) \u2013 The lower bounds for the subtomogram. shape ( ndarray ) \u2013 The shape of the subtomogram. Source code in tomogram_datasets/subtomogram.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , parent_tomogram : 'Tomogram' , lower_bounds : np . ndarray , shape : np . ndarray ) -> None : \"\"\" Initializes a Subtomogram instance. Args: parent_tomogram (Tomogram): The parent tomogram. lower_bounds (np.ndarray): The lower bounds for the subtomogram. shape (np.ndarray): The shape of the subtomogram. \"\"\" self . parent_tomogram = parent_tomogram self . lower_bounds = lower_bounds # Modify annotations from the parent tomogram to match this tomogram new_annotations : List [ Annotation ] = [] for parent_annotation in self . parent_tomogram . annotations : new_points : List [ np . ndarray ] = [] # Offset original points for this new subtomogram for point in parent_annotation . points : new_point = point - lower_bounds # Check if new_point is even in the new tomogram if _in_bounds ( shape , new_point ): new_points . append ( new_point ) # Otherwise continue # Add the annotation only if there are points in it if len ( new_points ) > 0 : new_annotations . append ( Annotation ( new_points , parent_annotation . name )) # Get subvolume data using lower bounds and shape min_0 , min_1 , min_2 = lower_bounds shape_0 , shape_1 , shape_2 = shape new_data = parent_tomogram . data [ min_0 : min_0 + shape_0 , min_1 : min_1 + shape_1 , min_2 : min_2 + shape_2 ] # Initialize this new Tomogram super () . __init__ ( new_data , new_annotations )","title":"__init__"},{"location":"subtomogram/#tomogram_datasets.subtomogram.SubtomogramGenerator","text":"A class for generating subtomograms from a parent tomogram. Attributes: tomogram ( Tomogram ) \u2013 The parent tomogram to sample from. annotations ( List [ Annotation ] ) \u2013 The annotations from the parent vol_shape ( Tuple [ int , int , int ] ) \u2013 The shape of the volumes to be pads ( Tuple [ int , int , int ] ) \u2013 The padding to apply to the boundaries. gen ( Generator ) \u2013 Random number generator for sampling. Source code in tomogram_datasets/subtomogram.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class SubtomogramGenerator : \"\"\" A class for generating subtomograms from a parent tomogram. Attributes: tomogram (Tomogram): The parent tomogram to sample from. annotations (List[Annotation]): The annotations from the parent tomogram. vol_shape (Tuple[int, int, int]): The shape of the volumes to be generated. pads (Tuple[int, int, int]): The padding to apply to the boundaries. gen (np.random.Generator): Random number generator for sampling. \"\"\" def __init__ ( self , tomogram : 'Tomogram' ) -> None : \"\"\" Initializes a SubtomogramGenerator instance. Args: tomogram (Tomogram): The parent tomogram to sample from. \"\"\" self . tomogram = tomogram self . tomogram . load () self . annotations = self . tomogram . annotations self . vol_shape = ( 64 , 256 , 256 ) self . pads = ( 8 , 32 , 32 ) self . gen = np . random . default_rng () def set_vol_shape ( self , new_vol_shape : tuple [ int , int , int ]): \"\"\" Sets a new volume shape for the generator. Args: new_vol_shape (tuple[int, int, int]): The new volume shape. \"\"\" self . vol_shape = new_vol_shape def positive_sample ( self , point : Optional [ np . ndarray ] = None ) -> Subtomogram : \"\"\" Returns a random subtomogram containing the specified point. The point will not be closer than `pads` voxels to the respective borders. If no point is given, a random annotation point from self.tomogram's annotations is selected. Args: point (Optional[np.ndarray]): The point to include in the subtomogram. Defaults to None. Returns: The newly created subtomogram. \"\"\" if point is None : # Pick a random annotation point from self.tomogram's annotations annotation = self . gen . choice ( self . annotations ) point = self . gen . choice ( annotation . points ) possible_lower_bounds = [ np . linspace ( max ( 0 , pt - vs + pad ), min ( ts - vs , pt - pad ), endpoint = False , dtype = int ) for ( ts , vs , pt , pad ) in zip ( self . tomogram . shape , self . vol_shape , point , self . pads )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Construct a new Tomogram with modified annotations return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape ) def negative_sample ( self ) -> Subtomogram : \"\"\" Returns a random subtomogram that does not contain any points from the annotations. This process continues until a valid subtomogram is found or the maximum iterations are reached. Returns: The newly created subtomogram. Raises: Exception: If unable to find a valid subtomogram without annotation points after 1000 attempts. \"\"\" # Generate completely random bounds until one has no annotations maxiter = 1000 for iter in range ( maxiter ): possible_lower_bounds = [ np . linspace ( 0 , ts - vs , endpoint = False , dtype = int ) for ( ts , vs ) in zip ( self . tomogram . shape , self . vol_shape )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Check if this volume contains any annotation points contains_annotation = False for point in self . tomogram . annotation_points (): new_point = point - lower_bounds if _in_bounds ( self . vol_shape , new_point ): contains_annotation = True break if not contains_annotation : return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape ) raise Exception ( \"Failed to find a volume without an annotation\" ) def find_annotation_points ( self ) -> List [ np . ndarray ]: \"\"\" Returns a list of points that are present in the annotations. Returns: A list of annotation points. \"\"\" points : List [ np . ndarray ] = [] for annotation in self . annotations : points += annotation . points return points","title":"SubtomogramGenerator"},{"location":"subtomogram/#tomogram_datasets.subtomogram.SubtomogramGenerator.__init__","text":"Initializes a SubtomogramGenerator instance. Parameters: tomogram ( Tomogram ) \u2013 The parent tomogram to sample from. Source code in tomogram_datasets/subtomogram.py 104 105 106 107 108 109 110 111 112 113 114 115 116 def __init__ ( self , tomogram : 'Tomogram' ) -> None : \"\"\" Initializes a SubtomogramGenerator instance. Args: tomogram (Tomogram): The parent tomogram to sample from. \"\"\" self . tomogram = tomogram self . tomogram . load () self . annotations = self . tomogram . annotations self . vol_shape = ( 64 , 256 , 256 ) self . pads = ( 8 , 32 , 32 ) self . gen = np . random . default_rng ()","title":"__init__"},{"location":"subtomogram/#tomogram_datasets.subtomogram.SubtomogramGenerator.find_annotation_points","text":"Returns a list of points that are present in the annotations. Returns: List [ ndarray ] \u2013 A list of annotation points. Source code in tomogram_datasets/subtomogram.py 202 203 204 205 206 207 208 209 210 211 212 def find_annotation_points ( self ) -> List [ np . ndarray ]: \"\"\" Returns a list of points that are present in the annotations. Returns: A list of annotation points. \"\"\" points : List [ np . ndarray ] = [] for annotation in self . annotations : points += annotation . points return points","title":"find_annotation_points"},{"location":"subtomogram/#tomogram_datasets.subtomogram.SubtomogramGenerator.negative_sample","text":"Returns a random subtomogram that does not contain any points from the annotations. This process continues until a valid subtomogram is found or the maximum iterations are reached. Returns: Subtomogram \u2013 The newly created subtomogram. Raises: Exception \u2013 If unable to find a valid subtomogram without annotation Source code in tomogram_datasets/subtomogram.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def negative_sample ( self ) -> Subtomogram : \"\"\" Returns a random subtomogram that does not contain any points from the annotations. This process continues until a valid subtomogram is found or the maximum iterations are reached. Returns: The newly created subtomogram. Raises: Exception: If unable to find a valid subtomogram without annotation points after 1000 attempts. \"\"\" # Generate completely random bounds until one has no annotations maxiter = 1000 for iter in range ( maxiter ): possible_lower_bounds = [ np . linspace ( 0 , ts - vs , endpoint = False , dtype = int ) for ( ts , vs ) in zip ( self . tomogram . shape , self . vol_shape )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Check if this volume contains any annotation points contains_annotation = False for point in self . tomogram . annotation_points (): new_point = point - lower_bounds if _in_bounds ( self . vol_shape , new_point ): contains_annotation = True break if not contains_annotation : return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape ) raise Exception ( \"Failed to find a volume without an annotation\" )","title":"negative_sample"},{"location":"subtomogram/#tomogram_datasets.subtomogram.SubtomogramGenerator.positive_sample","text":"Returns a random subtomogram containing the specified point. The point will not be closer than pads voxels to the respective borders. If no point is given, a random annotation point from self.tomogram's annotations is selected. Parameters: point ( Optional [ ndarray ] , default: None ) \u2013 The point to include in the Returns: Subtomogram \u2013 The newly created subtomogram. Source code in tomogram_datasets/subtomogram.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def positive_sample ( self , point : Optional [ np . ndarray ] = None ) -> Subtomogram : \"\"\" Returns a random subtomogram containing the specified point. The point will not be closer than `pads` voxels to the respective borders. If no point is given, a random annotation point from self.tomogram's annotations is selected. Args: point (Optional[np.ndarray]): The point to include in the subtomogram. Defaults to None. Returns: The newly created subtomogram. \"\"\" if point is None : # Pick a random annotation point from self.tomogram's annotations annotation = self . gen . choice ( self . annotations ) point = self . gen . choice ( annotation . points ) possible_lower_bounds = [ np . linspace ( max ( 0 , pt - vs + pad ), min ( ts - vs , pt - pad ), endpoint = False , dtype = int ) for ( ts , vs , pt , pad ) in zip ( self . tomogram . shape , self . vol_shape , point , self . pads )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Construct a new Tomogram with modified annotations return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape )","title":"positive_sample"},{"location":"subtomogram/#tomogram_datasets.subtomogram.SubtomogramGenerator.set_vol_shape","text":"Sets a new volume shape for the generator. Parameters: new_vol_shape ( tuple [ int , int , int ] ) \u2013 The new volume shape. Source code in tomogram_datasets/subtomogram.py 118 119 120 121 122 123 124 125 def set_vol_shape ( self , new_vol_shape : tuple [ int , int , int ]): \"\"\" Sets a new volume shape for the generator. Args: new_vol_shape (tuple[int, int, int]): The new volume shape. \"\"\" self . vol_shape = new_vol_shape","title":"set_vol_shape"},{"location":"supercomputer_utils/","text":"A collection of utilities for use on BYU's supercomputer. all_fm_negative_tomograms ( * , include_private = False ) Collect all .rec tomogram filepaths that have (probably, for now) been reviewed and do not have flagellar motors. Does not initially load the tomogram image data. Given a Tomogram called tomo , one can load and access the image data in one step with tomo.get_data() . IN DEVELOPMENT These results need to be manually checked. Parameters: include_private ( bool , default: False ) \u2013 Whether to include our newest annotations, which Returns: List [ TomogramFile ] \u2013 TomogramFile objects with no annotations attached. Source code in tomogram_datasets/supercomputer_utils.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 def all_fm_negative_tomograms ( * , include_private : bool = False ) -> List [ TomogramFile ]: \"\"\" Collect all `.rec` tomogram filepaths that have (probably, for now) been reviewed and do not have flagellar motors. Does not initially load the tomogram image data. Given a `Tomogram` called `tomo`, one can load and access the image data in one step with `tomo.get_data()`. **IN DEVELOPMENT** These results need to be manually checked. Args: include_private (bool): Whether to include our newest annotations, which should not be available to the public. Defaults to False. Returns: TomogramFile objects with no annotations attached. \"\"\" tomograms = [] # ~~~ DRIVE 1 ~~~ # # Hylemonella root = f \"/grphome/grp_tomo_db1_d1/nobackup/archive/TomoDB1_d1/FlagellarMotor_P1/Hylemonella gracilis\" dir_regex = re . compile ( r \"yc\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^fm.mod$\" , re . IGNORECASE ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # ~~~ DRIVE 2 ~~~ # # Legionella root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/legionella\" dir_regex = re . compile ( r \"dg\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # Pseudomonas root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/Pseudomonasaeruginosa/done\" dir_regex = re . compile ( r \"ab\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # Proteus_mirabilis root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/Proteus_mirabilis\" dir_regex = re . compile ( r \"qya\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # ~~~ DRIVE 3 ~~~ # # Bdellovibrio root = f \"/grphome/grp_tomo_db1_d3/nobackup/archive/TomoDB1_d3/jhome_extra/Bdellovibrio_YW\" dir_regex = re . compile ( r \"yc\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^flagellum_SIRT_1k\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # Azospirillum root = f \"/grphome/grp_tomo_db1_d3/nobackup/archive/TomoDB1_d3/jhome_extra/AzospirillumBrasilense/done\" dir_regex = re . compile ( r \"ab\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM3\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms ### ANNOTATIONS BEYOND HERE ARE PRIVATE ### if not include_private : return tomograms # ~~~ ZHIPING ~~~ # root = f \"/grphome/fslg_imagseg/nobackup/archive/zhiping_data/caulo_WT/\" dir_regex = re . compile ( r \"rrb\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^flagellum\\.mod$\" ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # ~~~ ANNOTATION PARTY ~~~ # root = f \"/grphome/grp_tomo_db1_d4/nobackup/archive/ExperimentRuns/\" dir_regex = re . compile ( r \"(sma\\d {4} .*)|(Vibrio.*)\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"flagellar_motor\\.mod\" ) tomogram_regex = re . compile ( r \".*\\.mrc$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms return tomograms all_fm_tomograms ( * , include_private = False ) Collect all pairs of .rec tomogram filepaths and flagellar motor .mod filepaths. Does not initially load the tomogram image data. Given a Tomogram called tomo , one can load and access the image data in one step with tomo.get_data() . Parameters: include_private ( bool , default: False ) \u2013 Whether to include our newest annotations, which Returns: List [ TomogramFile ] \u2013 TomogramFile objects with their annotations. Source code in tomogram_datasets/supercomputer_utils.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def all_fm_tomograms ( * , include_private : bool = False ) -> List [ TomogramFile ]: \"\"\" Collect all pairs of `.rec` tomogram filepaths and flagellar motor `.mod` filepaths. Does not initially load the tomogram image data. Given a `Tomogram` called `tomo`, one can load and access the image data in one step with `tomo.get_data()`. Args: include_private (bool): Whether to include our newest annotations, which should not be available to the public. Defaults to False. Returns: TomogramFile objects with their annotations. \"\"\" tomograms = [] # ~~~ DRIVE 1 ~~~ # # Hylemonella root = f \"/grphome/grp_tomo_db1_d1/nobackup/archive/TomoDB1_d1/FlagellarMotor_P1/Hylemonella gracilis\" dir_regex = re . compile ( r \"yc\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^fm.mod$\" , re . IGNORECASE ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # ~~~ DRIVE 2 ~~~ # # Legionella root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/legionella\" dir_regex = re . compile ( r \"dg\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Pseudomonas root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/Pseudomonasaeruginosa/done\" dir_regex = re . compile ( r \"ab\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Proteus_mirabilis root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/Proteus_mirabilis\" dir_regex = re . compile ( r \"qya\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # ~~~ DRIVE 3 ~~~ # # Bdellovibrio root = f \"/grphome/grp_tomo_db1_d3/nobackup/archive/TomoDB1_d3/jhome_extra/Bdellovibrio_YW\" dir_regex = re . compile ( r \"yc\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^flagellum_SIRT_1k\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Azospirillum root = f \"/grphome/grp_tomo_db1_d3/nobackup/archive/TomoDB1_d3/jhome_extra/AzospirillumBrasilense/done\" dir_regex = re . compile ( r \"ab\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM3\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms ### ANNOTATIONS BEYOND HERE ARE PRIVATE ### if not include_private : return tomograms # ~~~ ZHIPING ~~~ # root = f \"/grphome/fslg_imagseg/nobackup/archive/zhiping_data/caulo_WT/\" dir_regex = re . compile ( r \"rrb\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^flagellum\\.mod$\" ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # ~~~ ANNOTATION PARTY ~~~ # root = f \"/grphome/grp_tomo_db1_d4/nobackup/archive/ExperimentRuns/\" dir_regex = re . compile ( r \"(sma\\d {4} .*)|(Vibrio.*)\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"flagellar_motor\\.mod\" ) tomogram_regex = re . compile ( r \".*\\.mrc$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms return tomograms seek_annotated_tomos ( directories , tomo_regex , annotation_regexes , annotation_names ) Collect pairs of tomogram files and their corresponding annotation files, without loading the tomograms. Parameters: directories ( list of str ) \u2013 List of directories to search for tomograms tomo_regex ( Pattern ) \u2013 The regex pattern to match tomogram filenames. annotation_regexes ( list of re.Pattern ) \u2013 A list of regex patterns to annotation_names ( list of str ) \u2013 A list of names for the annotations. Returns: List [ TomogramFile ] \u2013 TomogramFile objects with their corresponding annotations. Source code in tomogram_datasets/supercomputer_utils.py 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 def seek_annotated_tomos ( directories : List [ str ], tomo_regex : re . Pattern , annotation_regexes : List [ re . Pattern ], annotation_names : List [ str ] ) -> List [ TomogramFile ]: \"\"\" Collect pairs of tomogram files and their corresponding annotation files, without loading the tomograms. Args: directories (list of str): List of directories to search for tomograms and annotations. tomo_regex (re.Pattern): The regex pattern to match tomogram filenames. annotation_regexes (list of re.Pattern): A list of regex patterns to match annotation filenames. annotation_names (list of str): A list of names for the annotations. Returns: TomogramFile objects with their corresponding annotations. \"\"\" tomos = [] for dir in directories : matches = seek_set ( dir , [ tomo_regex ] + annotation_regexes ) if matches is not None and None not in matches : tomogram_file = matches [ 0 ] annotation_files = matches [ 1 :] annotations = [] for ( file , name ) in zip ( annotation_files , annotation_names ): try : annotations . append ( AnnotationFile ( file , name )) except Exception as e : print ( f \"An exception occured while loading ` { file } `: \\n { e } \\n \" ) tomo = TomogramFile ( tomogram_file , annotations , load = False ) tomos . append ( tomo ) return tomos seek_dirs ( root , regex , directories = None ) Search for directories matching the given regex recursively within the specified root directory. Parameters: root ( str ) \u2013 The root directory to start the search. regex ( Pattern ) \u2013 The regex pattern to match the directory names. directories ( list , default: None ) \u2013 A list to accumulate matched directories. Returns: Union [ List [ str ], None] \u2013 A list of paths of matching directories. Source code in tomogram_datasets/supercomputer_utils.py 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 def seek_dirs ( root : str , regex : re . Pattern , directories : Optional [ List [ str ]] = None ) -> Union [ List [ str ], None ]: \"\"\"Search for directories matching the given regex recursively within the specified root directory. Args: root (str): The root directory to start the search. regex (re.Pattern): The regex pattern to match the directory names. directories (list, optional): A list to accumulate matched directories. Should not be set in general usage, as this is used only for internal recursion. Defaults to None. Returns: A list of paths of matching directories. \"\"\" if directories is None : directories = [] for this_root , dirs , _ in os . walk ( root ): for dir in dirs : if regex . match ( dir ): directories . append ( os . path . join ( this_root , dir )) else : directories = seek_dirs ( dir , regex , directories ) return directories seek_file ( directory , regex ) Search for a file matching the given regex recursively in the specified directory. Parameters: directory ( str ) \u2013 The root directory to start the search. regex regex ( Pattern ) \u2013 The regex pattern to match the filenames. Returns: Union [ str , None] \u2013 The full path of the matching file, or None if no match is Union [ str , None] \u2013 found. Source code in tomogram_datasets/supercomputer_utils.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 def seek_file ( directory : str , regex : re . Pattern ) -> Union [ str , None ]: \"\"\"Search for a file matching the given regex recursively in the specified directory. Args: directory (str): The root directory to start the search. regex regex (re.Pattern): The regex pattern to match the filenames. Returns: The full path of the matching file, or None if no match is found. \"\"\" for root , dirs , files in os . walk ( directory ): for file in files : if regex . match ( file ): return os . path . join ( root , file ) for dir in dirs : target = seek_file ( dir , regex ) if target is not None : return target return None seek_files ( directory , regex , files = None ) Search for all files matching the given regex recursively in the specified directory. Parameters: directory ( str ) \u2013 The root directory to start the search. regex ( Pattern ) \u2013 The regex pattern to match the filenames. files ( list , default: None ) \u2013 A list to accumulate matched files. Returns: List [ str ] \u2013 A list of the full paths of each matching file. Source code in tomogram_datasets/supercomputer_utils.py 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 def seek_files ( directory : str , regex : re . Pattern , files : Optional [ List [ str ]] = None ) -> List [ str ]: \"\"\"Search for all files matching the given regex recursively in the specified directory. Args: directory (str): The root directory to start the search. regex (re.Pattern): The regex pattern to match the filenames. files (list, optional): A list to accumulate matched files. Should not be set in general usage, as this is used only for internal recursion. Defaults to None. Returns: A list of the full paths of each matching file. \"\"\" if files is None : files = [] for root , dirs , dir_files in os . walk ( directory ): for dir_file in dir_files : if regex . match ( dir_file ): files . append ( os . path . join ( root , dir_file )) for dir in dirs : files = seek_files ( os . path . join ( root , dir ), regex , files ) return files seek_set ( directory , regexes , matches = None ) Recursively search the specified directory for exactly one match for each regex in the list. Parameters: directory ( str ) \u2013 The directory to search. regexes ( list of re.Pattern ) \u2013 A list of regex patterns to match filenames. matches ( list , default: None ) \u2013 A list to accumulate matches. Should not be Returns: Union [ List [ str ], None] \u2013 A list of matching file paths or None if extra matches are found. Source code in tomogram_datasets/supercomputer_utils.py 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 def seek_set ( directory : str , regexes : List [ re . Pattern ], matches : List [ str ] = None ) -> Union [ List [ str ], None ]: \"\"\"Recursively search the specified directory for exactly one match for each regex in the list. Args: directory (str): The directory to search. regexes (list of re.Pattern): A list of regex patterns to match filenames. matches (list, optional): A list to accumulate matches. Should not be set in general usage, as this is used only for internal recursion. Defaults to None. Returns: A list of matching file paths or None if extra matches are found. \"\"\" if matches is None : matches = [ None for _ in regexes ] for root , dirs , files in os . walk ( directory ): for file in files : for r_idx , r in enumerate ( regexes ): if re . match ( r , file ): if matches [ r_idx ] is None : matches [ r_idx ] = os . path . join ( root , file ) else : return None # Extra match found return matches seek_unannotated_tomos ( directories , tomo_regex , annotation_regexes ) Collect tomogram files that don't have annotations, without loading the tomograms. Parameters: directories ( list of str ) \u2013 List of directories to search for tomograms tomo_regex ( Pattern ) \u2013 The regex pattern to match tomogram filenames. annotation_regexes ( list of re.Pattern ) \u2013 A list of regex patterns. If Returns: List [ TomogramFile ] \u2013 TomogramFile objects. Source code in tomogram_datasets/supercomputer_utils.py 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 def seek_unannotated_tomos ( directories : List [ str ], tomo_regex : re . Pattern , annotation_regexes : List [ re . Pattern ], ) -> List [ TomogramFile ]: \"\"\" Collect tomogram files that don't have annotations, without loading the tomograms. Args: directories (list of str): List of directories to search for tomograms and annotations. tomo_regex (re.Pattern): The regex pattern to match tomogram filenames. annotation_regexes (list of re.Pattern): A list of regex patterns. If any of these patterns find a match for one of the files in a given directory in `directories`, the tomogram in that directory will not be saved and returned. Returns: TomogramFile objects. \"\"\" tomos = [] for dir in directories : matches = seek_set ( dir , [ tomo_regex ] + annotation_regexes ) if matches is not None and None not in matches : # This tomogram is annotated continue else : # Ensure that there is a tomogram in this directory tomo_candidates = seek_files ( dir , tomo_regex ) n_candidates = len ( tomo_candidates ) # If there are multiple possible unannotated tomogram candidates or # none here, that's an issue. if n_candidates > 1 : warnings . warn ( f \"Multiple ( { n_candidates } ) unannotated tomograms in { dir } found. This may mean that the regular expression used to seek tomograms is not specific enough, or that this directory is strange.\" ) continue elif n_candidates == 0 : warnings . warn ( f \"No tomograms found in { dir } .\" ) continue # If there is one candidate, it isn't annotated. else : # Append what must be the only unannotated tomogram candidate tomogram_file = tomo_candidates [ 0 ] tomo = TomogramFile ( tomogram_file , load = False ) tomos . append ( tomo ) return tomos","title":"Supercomputer utils"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils.all_fm_negative_tomograms","text":"Collect all .rec tomogram filepaths that have (probably, for now) been reviewed and do not have flagellar motors. Does not initially load the tomogram image data. Given a Tomogram called tomo , one can load and access the image data in one step with tomo.get_data() . IN DEVELOPMENT These results need to be manually checked. Parameters: include_private ( bool , default: False ) \u2013 Whether to include our newest annotations, which Returns: List [ TomogramFile ] \u2013 TomogramFile objects with no annotations attached. Source code in tomogram_datasets/supercomputer_utils.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 def all_fm_negative_tomograms ( * , include_private : bool = False ) -> List [ TomogramFile ]: \"\"\" Collect all `.rec` tomogram filepaths that have (probably, for now) been reviewed and do not have flagellar motors. Does not initially load the tomogram image data. Given a `Tomogram` called `tomo`, one can load and access the image data in one step with `tomo.get_data()`. **IN DEVELOPMENT** These results need to be manually checked. Args: include_private (bool): Whether to include our newest annotations, which should not be available to the public. Defaults to False. Returns: TomogramFile objects with no annotations attached. \"\"\" tomograms = [] # ~~~ DRIVE 1 ~~~ # # Hylemonella root = f \"/grphome/grp_tomo_db1_d1/nobackup/archive/TomoDB1_d1/FlagellarMotor_P1/Hylemonella gracilis\" dir_regex = re . compile ( r \"yc\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^fm.mod$\" , re . IGNORECASE ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # ~~~ DRIVE 2 ~~~ # # Legionella root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/legionella\" dir_regex = re . compile ( r \"dg\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # Pseudomonas root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/Pseudomonasaeruginosa/done\" dir_regex = re . compile ( r \"ab\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # Proteus_mirabilis root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/Proteus_mirabilis\" dir_regex = re . compile ( r \"qya\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # ~~~ DRIVE 3 ~~~ # # Bdellovibrio root = f \"/grphome/grp_tomo_db1_d3/nobackup/archive/TomoDB1_d3/jhome_extra/Bdellovibrio_YW\" dir_regex = re . compile ( r \"yc\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^flagellum_SIRT_1k\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # Azospirillum root = f \"/grphome/grp_tomo_db1_d3/nobackup/archive/TomoDB1_d3/jhome_extra/AzospirillumBrasilense/done\" dir_regex = re . compile ( r \"ab\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM3\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms ### ANNOTATIONS BEYOND HERE ARE PRIVATE ### if not include_private : return tomograms # ~~~ ZHIPING ~~~ # root = f \"/grphome/fslg_imagseg/nobackup/archive/zhiping_data/caulo_WT/\" dir_regex = re . compile ( r \"rrb\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^flagellum\\.mod$\" ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # ~~~ ANNOTATION PARTY ~~~ # root = f \"/grphome/grp_tomo_db1_d4/nobackup/archive/ExperimentRuns/\" dir_regex = re . compile ( r \"(sma\\d {4} .*)|(Vibrio.*)\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"flagellar_motor\\.mod\" ) tomogram_regex = re . compile ( r \".*\\.mrc$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms return tomograms","title":"all_fm_negative_tomograms"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils.all_fm_tomograms","text":"Collect all pairs of .rec tomogram filepaths and flagellar motor .mod filepaths. Does not initially load the tomogram image data. Given a Tomogram called tomo , one can load and access the image data in one step with tomo.get_data() . Parameters: include_private ( bool , default: False ) \u2013 Whether to include our newest annotations, which Returns: List [ TomogramFile ] \u2013 TomogramFile objects with their annotations. Source code in tomogram_datasets/supercomputer_utils.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def all_fm_tomograms ( * , include_private : bool = False ) -> List [ TomogramFile ]: \"\"\" Collect all pairs of `.rec` tomogram filepaths and flagellar motor `.mod` filepaths. Does not initially load the tomogram image data. Given a `Tomogram` called `tomo`, one can load and access the image data in one step with `tomo.get_data()`. Args: include_private (bool): Whether to include our newest annotations, which should not be available to the public. Defaults to False. Returns: TomogramFile objects with their annotations. \"\"\" tomograms = [] # ~~~ DRIVE 1 ~~~ # # Hylemonella root = f \"/grphome/grp_tomo_db1_d1/nobackup/archive/TomoDB1_d1/FlagellarMotor_P1/Hylemonella gracilis\" dir_regex = re . compile ( r \"yc\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^fm.mod$\" , re . IGNORECASE ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # ~~~ DRIVE 2 ~~~ # # Legionella root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/legionella\" dir_regex = re . compile ( r \"dg\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Pseudomonas root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/Pseudomonasaeruginosa/done\" dir_regex = re . compile ( r \"ab\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Proteus_mirabilis root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/Proteus_mirabilis\" dir_regex = re . compile ( r \"qya\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # ~~~ DRIVE 3 ~~~ # # Bdellovibrio root = f \"/grphome/grp_tomo_db1_d3/nobackup/archive/TomoDB1_d3/jhome_extra/Bdellovibrio_YW\" dir_regex = re . compile ( r \"yc\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^flagellum_SIRT_1k\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Azospirillum root = f \"/grphome/grp_tomo_db1_d3/nobackup/archive/TomoDB1_d3/jhome_extra/AzospirillumBrasilense/done\" dir_regex = re . compile ( r \"ab\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM3\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms ### ANNOTATIONS BEYOND HERE ARE PRIVATE ### if not include_private : return tomograms # ~~~ ZHIPING ~~~ # root = f \"/grphome/fslg_imagseg/nobackup/archive/zhiping_data/caulo_WT/\" dir_regex = re . compile ( r \"rrb\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^flagellum\\.mod$\" ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # ~~~ ANNOTATION PARTY ~~~ # root = f \"/grphome/grp_tomo_db1_d4/nobackup/archive/ExperimentRuns/\" dir_regex = re . compile ( r \"(sma\\d {4} .*)|(Vibrio.*)\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"flagellar_motor\\.mod\" ) tomogram_regex = re . compile ( r \".*\\.mrc$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms return tomograms","title":"all_fm_tomograms"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils.seek_annotated_tomos","text":"Collect pairs of tomogram files and their corresponding annotation files, without loading the tomograms. Parameters: directories ( list of str ) \u2013 List of directories to search for tomograms tomo_regex ( Pattern ) \u2013 The regex pattern to match tomogram filenames. annotation_regexes ( list of re.Pattern ) \u2013 A list of regex patterns to annotation_names ( list of str ) \u2013 A list of names for the annotations. Returns: List [ TomogramFile ] \u2013 TomogramFile objects with their corresponding annotations. Source code in tomogram_datasets/supercomputer_utils.py 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 def seek_annotated_tomos ( directories : List [ str ], tomo_regex : re . Pattern , annotation_regexes : List [ re . Pattern ], annotation_names : List [ str ] ) -> List [ TomogramFile ]: \"\"\" Collect pairs of tomogram files and their corresponding annotation files, without loading the tomograms. Args: directories (list of str): List of directories to search for tomograms and annotations. tomo_regex (re.Pattern): The regex pattern to match tomogram filenames. annotation_regexes (list of re.Pattern): A list of regex patterns to match annotation filenames. annotation_names (list of str): A list of names for the annotations. Returns: TomogramFile objects with their corresponding annotations. \"\"\" tomos = [] for dir in directories : matches = seek_set ( dir , [ tomo_regex ] + annotation_regexes ) if matches is not None and None not in matches : tomogram_file = matches [ 0 ] annotation_files = matches [ 1 :] annotations = [] for ( file , name ) in zip ( annotation_files , annotation_names ): try : annotations . append ( AnnotationFile ( file , name )) except Exception as e : print ( f \"An exception occured while loading ` { file } `: \\n { e } \\n \" ) tomo = TomogramFile ( tomogram_file , annotations , load = False ) tomos . append ( tomo ) return tomos","title":"seek_annotated_tomos"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils.seek_dirs","text":"Search for directories matching the given regex recursively within the specified root directory. Parameters: root ( str ) \u2013 The root directory to start the search. regex ( Pattern ) \u2013 The regex pattern to match the directory names. directories ( list , default: None ) \u2013 A list to accumulate matched directories. Returns: Union [ List [ str ], None] \u2013 A list of paths of matching directories. Source code in tomogram_datasets/supercomputer_utils.py 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 def seek_dirs ( root : str , regex : re . Pattern , directories : Optional [ List [ str ]] = None ) -> Union [ List [ str ], None ]: \"\"\"Search for directories matching the given regex recursively within the specified root directory. Args: root (str): The root directory to start the search. regex (re.Pattern): The regex pattern to match the directory names. directories (list, optional): A list to accumulate matched directories. Should not be set in general usage, as this is used only for internal recursion. Defaults to None. Returns: A list of paths of matching directories. \"\"\" if directories is None : directories = [] for this_root , dirs , _ in os . walk ( root ): for dir in dirs : if regex . match ( dir ): directories . append ( os . path . join ( this_root , dir )) else : directories = seek_dirs ( dir , regex , directories ) return directories","title":"seek_dirs"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils.seek_file","text":"Search for a file matching the given regex recursively in the specified directory. Parameters: directory ( str ) \u2013 The root directory to start the search. regex regex ( Pattern ) \u2013 The regex pattern to match the filenames. Returns: Union [ str , None] \u2013 The full path of the matching file, or None if no match is Union [ str , None] \u2013 found. Source code in tomogram_datasets/supercomputer_utils.py 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 def seek_file ( directory : str , regex : re . Pattern ) -> Union [ str , None ]: \"\"\"Search for a file matching the given regex recursively in the specified directory. Args: directory (str): The root directory to start the search. regex regex (re.Pattern): The regex pattern to match the filenames. Returns: The full path of the matching file, or None if no match is found. \"\"\" for root , dirs , files in os . walk ( directory ): for file in files : if regex . match ( file ): return os . path . join ( root , file ) for dir in dirs : target = seek_file ( dir , regex ) if target is not None : return target return None","title":"seek_file"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils.seek_files","text":"Search for all files matching the given regex recursively in the specified directory. Parameters: directory ( str ) \u2013 The root directory to start the search. regex ( Pattern ) \u2013 The regex pattern to match the filenames. files ( list , default: None ) \u2013 A list to accumulate matched files. Returns: List [ str ] \u2013 A list of the full paths of each matching file. Source code in tomogram_datasets/supercomputer_utils.py 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 def seek_files ( directory : str , regex : re . Pattern , files : Optional [ List [ str ]] = None ) -> List [ str ]: \"\"\"Search for all files matching the given regex recursively in the specified directory. Args: directory (str): The root directory to start the search. regex (re.Pattern): The regex pattern to match the filenames. files (list, optional): A list to accumulate matched files. Should not be set in general usage, as this is used only for internal recursion. Defaults to None. Returns: A list of the full paths of each matching file. \"\"\" if files is None : files = [] for root , dirs , dir_files in os . walk ( directory ): for dir_file in dir_files : if regex . match ( dir_file ): files . append ( os . path . join ( root , dir_file )) for dir in dirs : files = seek_files ( os . path . join ( root , dir ), regex , files ) return files","title":"seek_files"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils.seek_set","text":"Recursively search the specified directory for exactly one match for each regex in the list. Parameters: directory ( str ) \u2013 The directory to search. regexes ( list of re.Pattern ) \u2013 A list of regex patterns to match filenames. matches ( list , default: None ) \u2013 A list to accumulate matches. Should not be Returns: Union [ List [ str ], None] \u2013 A list of matching file paths or None if extra matches are found. Source code in tomogram_datasets/supercomputer_utils.py 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 def seek_set ( directory : str , regexes : List [ re . Pattern ], matches : List [ str ] = None ) -> Union [ List [ str ], None ]: \"\"\"Recursively search the specified directory for exactly one match for each regex in the list. Args: directory (str): The directory to search. regexes (list of re.Pattern): A list of regex patterns to match filenames. matches (list, optional): A list to accumulate matches. Should not be set in general usage, as this is used only for internal recursion. Defaults to None. Returns: A list of matching file paths or None if extra matches are found. \"\"\" if matches is None : matches = [ None for _ in regexes ] for root , dirs , files in os . walk ( directory ): for file in files : for r_idx , r in enumerate ( regexes ): if re . match ( r , file ): if matches [ r_idx ] is None : matches [ r_idx ] = os . path . join ( root , file ) else : return None # Extra match found return matches","title":"seek_set"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils.seek_unannotated_tomos","text":"Collect tomogram files that don't have annotations, without loading the tomograms. Parameters: directories ( list of str ) \u2013 List of directories to search for tomograms tomo_regex ( Pattern ) \u2013 The regex pattern to match tomogram filenames. annotation_regexes ( list of re.Pattern ) \u2013 A list of regex patterns. If Returns: List [ TomogramFile ] \u2013 TomogramFile objects. Source code in tomogram_datasets/supercomputer_utils.py 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 def seek_unannotated_tomos ( directories : List [ str ], tomo_regex : re . Pattern , annotation_regexes : List [ re . Pattern ], ) -> List [ TomogramFile ]: \"\"\" Collect tomogram files that don't have annotations, without loading the tomograms. Args: directories (list of str): List of directories to search for tomograms and annotations. tomo_regex (re.Pattern): The regex pattern to match tomogram filenames. annotation_regexes (list of re.Pattern): A list of regex patterns. If any of these patterns find a match for one of the files in a given directory in `directories`, the tomogram in that directory will not be saved and returned. Returns: TomogramFile objects. \"\"\" tomos = [] for dir in directories : matches = seek_set ( dir , [ tomo_regex ] + annotation_regexes ) if matches is not None and None not in matches : # This tomogram is annotated continue else : # Ensure that there is a tomogram in this directory tomo_candidates = seek_files ( dir , tomo_regex ) n_candidates = len ( tomo_candidates ) # If there are multiple possible unannotated tomogram candidates or # none here, that's an issue. if n_candidates > 1 : warnings . warn ( f \"Multiple ( { n_candidates } ) unannotated tomograms in { dir } found. This may mean that the regular expression used to seek tomograms is not specific enough, or that this directory is strange.\" ) continue elif n_candidates == 0 : warnings . warn ( f \"No tomograms found in { dir } .\" ) continue # If there is one candidate, it isn't annotated. else : # Append what must be the only unannotated tomogram candidate tomogram_file = tomo_candidates [ 0 ] tomo = TomogramFile ( tomogram_file , load = False ) tomos . append ( tomo ) return tomos","title":"seek_unannotated_tomos"},{"location":"tomogram/","text":"Tomogram Represents a tomogram. Has fields for tomogram data and shape, as well as any annotations corresponding to the tomogram, which are represented with the Annotation class. Attributes: annotations ( list of Annotation ) \u2013 Annotations corresponding to this tomogram. data ( ndarray ) \u2013 A 3-dimensional array containing the tomogram image. shape ( ndarray ) \u2013 A 3-element array representing the shape of the tomogram data. Source code in tomogram_datasets/tomogram.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class Tomogram : \"\"\"Represents a tomogram. Has fields for tomogram data and shape, as well as any annotations corresponding to the tomogram, which are represented with the Annotation class. Attributes: annotations (list of Annotation): Annotations corresponding to this tomogram. data (numpy.ndarray): A 3-dimensional array containing the tomogram image. shape (numpy.ndarray): A 3-element array representing the shape of the tomogram data. \"\"\" def __init__ ( self , data : np . ndarray , annotations : Optional [ List [ Annotation ]] = None ): \"\"\"Initialize a Tomogram instance. Args: data (numpy.ndarray): A 3-dimensional array containing the tomogram image. annotations (list of Annotation, optional): A list of annotations corresponding to the tomogram. Defaults to None. \"\"\" self . annotations = [] if annotations is None else annotations self . data = data self . shape = data . shape def add_annotation ( self , annotation : Annotation ): \"\"\"Add an annotation to the tomogram. Args: annotation (Annotation): An annotation object to be added to the tomogram's annotations. \"\"\" self . annotations . append ( annotation ) def annotation_points ( self , annotation_index : Optional [ int ] = None ): \"\"\"Get annotation points from the tomogram. Retrieves annotation points from a specific annotation if an index is provided, or all annotation points from all annotations if no index is given. Args: annotation_index (int, optional): The index of the annotation from which to retrieve points. If None, retrieves points from all annotations. Defaults to None. Returns: A list of points from the specified annotation or all annotations. \"\"\" if annotation_index is not None : return self . annotations [ annotation_index ] . points else : indices = range ( len ( self . annotations )) points = [] for index in indices : points += self . annotation_points ( index ) return points def get_data ( self ) -> np . ndarray : \"\"\"Access the data array in the tomogram. Returns: The array data of the tomogram. In other words, returns the image. \"\"\" return self . data __init__ ( data , annotations = None ) Initialize a Tomogram instance. Parameters: data ( ndarray ) \u2013 A 3-dimensional array containing the tomogram image. annotations ( list of Annotation , default: None ) \u2013 A list of annotations corresponding to the tomogram. Defaults to None. Source code in tomogram_datasets/tomogram.py 29 30 31 32 33 34 35 36 37 38 39 def __init__ ( self , data : np . ndarray , annotations : Optional [ List [ Annotation ]] = None ): \"\"\"Initialize a Tomogram instance. Args: data (numpy.ndarray): A 3-dimensional array containing the tomogram image. annotations (list of Annotation, optional): A list of annotations corresponding to the tomogram. Defaults to None. \"\"\" self . annotations = [] if annotations is None else annotations self . data = data self . shape = data . shape add_annotation ( annotation ) Add an annotation to the tomogram. Parameters: annotation ( Annotation ) \u2013 An annotation object to be added to the tomogram's annotations. Source code in tomogram_datasets/tomogram.py 41 42 43 44 45 46 47 48 def add_annotation ( self , annotation : Annotation ): \"\"\"Add an annotation to the tomogram. Args: annotation (Annotation): An annotation object to be added to the tomogram's annotations. \"\"\" self . annotations . append ( annotation ) annotation_points ( annotation_index = None ) Get annotation points from the tomogram. Retrieves annotation points from a specific annotation if an index is provided, or all annotation points from all annotations if no index is given. Parameters: annotation_index ( int , default: None ) \u2013 The index of the annotation from which to retrieve points. If None, retrieves points from all annotations. Defaults to None. Returns: \u2013 A list of points from the specified annotation or all annotations. Source code in tomogram_datasets/tomogram.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def annotation_points ( self , annotation_index : Optional [ int ] = None ): \"\"\"Get annotation points from the tomogram. Retrieves annotation points from a specific annotation if an index is provided, or all annotation points from all annotations if no index is given. Args: annotation_index (int, optional): The index of the annotation from which to retrieve points. If None, retrieves points from all annotations. Defaults to None. Returns: A list of points from the specified annotation or all annotations. \"\"\" if annotation_index is not None : return self . annotations [ annotation_index ] . points else : indices = range ( len ( self . annotations )) points = [] for index in indices : points += self . annotation_points ( index ) return points get_data () Access the data array in the tomogram. Returns: ndarray \u2013 The array data of the tomogram. In other words, returns the image. Source code in tomogram_datasets/tomogram.py 75 76 77 78 79 80 81 def get_data ( self ) -> np . ndarray : \"\"\"Access the data array in the tomogram. Returns: The array data of the tomogram. In other words, returns the image. \"\"\" return self . data TomogramFile Bases: Tomogram Represents a tomogram file. Extends the Tomogram class to handle file operations, including loading tomogram data from files of specific formats. Access the image data inside with get_data() . Attributes: filepath ( str ) \u2013 The file path to the tomogram file. annotations ( list of Annotation ) \u2013 Annotations corresponding to the tomogram. data ( ndarray ) \u2013 A 3-dimensional array containing the tomogram image. Source code in tomogram_datasets/tomogram.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 class TomogramFile ( Tomogram ): \"\"\"Represents a tomogram file. Extends the Tomogram class to handle file operations, including loading tomogram data from files of specific formats. Access the image data inside with `get_data()`. Attributes: filepath (str): The file path to the tomogram file. annotations (list of Annotation): Annotations corresponding to the tomogram. data (numpy.ndarray): A 3-dimensional array containing the tomogram image. header (dict or numpy.recarray) Other data related to the tomogram file. \"\"\" def __init__ ( self , filepath : str , annotations : Optional [ List [ Annotation ]] = None , * , load : bool = True ): \"\"\"Initialize a TomogramFile instance. Args: filepath (str): The file path to the tomogram file. annotations (list of Annotation, optional): Annotations corresponding to the tomogram. Defaults to None. load (bool, optional): Whether to load tomogram array data immediately. Defaults to True. If False, use self.load() when ready to load data. \"\"\" self . data = None self . annotations = annotations self . filepath = filepath self . load_header () if load : self . load () def load ( self , * , preprocess : bool = True ): \"\"\"Load the tomogram data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The loaded tomogram data. Raises: IOError: If the file type is not supported. \"\"\" if self . data is not None : return self . data # Determine how to load based on file extension. root , extension = os . path . splitext ( self . filepath ) if extension in [ \".mrc\" , \".rec\" ]: data = TomogramFile . mrc_to_np ( self . filepath ) elif extension == \".npy\" : data = np . load ( self . filepath ) else : raise IOError ( \"Tomogram file must be of type .mrc, .rec, or .npy.\" ) # Initialize Tomogram class super () . __init__ ( data , self . annotations ) if preprocess : self . process () return self . data def load_header ( self ) -> Union [ dict , np . recarray ]: \"\"\"Loads only tomogram header data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Returns: The loaded tomogram header data. Raises: IOError: If the file type is not supported. \"\"\" # Determine how to load based on file extension. root , extension = os . path . splitext ( self . filepath ) if extension in [ \".mrc\" , \".rec\" ]: mrc = mrcfile . open ( self . filepath , header_only = True ) self . header = mrc . header # Shape seems backward because python convention is reverse of # FORTRAN convention. This is deliberate. self . shape = tuple ( self . header [ dim ] . item () for dim in [ 'nz' , 'ny' , 'nx' ]) mrc . close () elif extension == \".npy\" : self . header = dict () else : raise IOError ( \"Tomogram file must be of type .mrc, .rec, or .npy.\" ) return self . header def get_data ( self , * , preprocess : bool = True ) -> np . ndarray : \"\"\" Access the data array in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The array data of the tomogram. In other words, returns the image. \"\"\" return self . load () def get_shape ( self , * , preprocess : bool = True ) -> np . ndarray : \"\"\" Access the data array shape in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array shape. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The data array shape of the tomogram. In other words, returns the image's dimensions. \"\"\" return self . shape def get_voxel_spacing ( self ): \"\"\" Uses `.mrc` file header information to find the voxel spacing of this tomogram in \u00c5ngstroms. Returns: Either an integer (if the voxel spacing is isotropic, i.e., the same in all directions), or a 3-tuple (if the spacing is anisotropic) representing the voxel spacing in each direction. Raises: IOError: If the file type is not `.mrc`. \"\"\" # Determine file extension. root , extension = os . path . splitext ( self . filepath ) if extension not in [ \".mrc\" , \".rec\" ]: raise IOError ( \"Tomogram file must be .mrc to load the voxel spacing.\" ) mrc = mrcfile . open ( self . filepath , mode = 'r' , header_only = True ) spacing = mrc . voxel_size # Convert pesky np.recarray to a normal ndarray if isinstance ( spacing , np . recarray ): spacing = np . array ([ spacing . x . item (), spacing . y . item (), spacing . z . item ()]) # If the spacing is already a scalar, return it. if isinstance ( spacing , ( int , float )): return spacing # If it isn't, check if all the tuple values are the same. # If so, just return one. If not, return the whole tuple if spacing [ 0 ] == spacing [ 1 ] and spacing [ 0 ] == spacing [ 2 ]: return spacing [ 0 ] else : return spacing @staticmethod def rescale ( array : np . ndarray ) -> np . ndarray : \"\"\"Rescale array values to the range [0, 1]. Args: array (numpy.ndarray): The array to be rescaled. Returns: The rescaled array. \"\"\" maximum = np . max ( array ) minimum = np . min ( array ) range_ = maximum - minimum return ( array - minimum ) / range_ @staticmethod def mrc_to_np ( filepath : str ) -> np . ndarray : \"\"\"Convert a .mrc or .rec file to a numpy array. Args: filepath (str): The file path to the .mrc or .rec file. Returns: The data loaded as a numpy array. \"\"\" with mrcfile . open ( filepath , 'r' ) as mrc : data = mrc . data . astype ( np . float64 ) return data def process ( self ) -> np . ndarray : \"\"\"Process the tomogram to improve contrast using contrast stretching. This method applies contrast stretching to enhance the visibility of features in the tomogram. Returns: The processed tomogram data. \"\"\" # Contrast stretching p2 , p98 = np . percentile ( self . get_data (), ( 2 , 98 )) data_rescale = exposure . rescale_intensity ( self . get_data (), in_range = ( p2 , p98 )) self . data = data_rescale return self . get_data () def reload ( self ) -> np . ndarray : \"\"\"Reload the tomogram data from the file. This method reinitializes the tomogram data by loading it again from the specified file. If the data has already been loaded, access it with self.get_data(). Returns: The reloaded tomogram data. \"\"\" self . data = TomogramFile . mrc_to_np ( self . filepath ) return self . get_data () def get_shape_from_annotations ( self ) -> np . ndarray : \"\"\" Returns the shape of the tomogram without having to load it using the annotations attatched to this tomogram, if any are AnnotationFiles. If no AnnotationFiles of `.mod` type are in self.annotations, raises an exception. Returns: The shape of the tomogram as inferred from self.annotations. Raises: Exception: If no AnnotationFile objects are in self.annotations. Exception: If there are multiple AnnotationFile objects in self.annotations and they imply inconsistent shapes. \"\"\" shapes = [] for annotation in self . annotations : if isinstance ( annotation , AnnotationFile ) and annotation . extension == \".mod\" : shape = annotation . tomogram_shape_from_mod () shapes . append ( shape ) if len ( shapes ) == 0 : raise Exception ( \"No .mod annotations found. Cannot infer tomogram shape.\" ) elif len ( shapes ) == 1 : return shapes [ 0 ] else : # Confirm that all the shapes agree shape = shapes [ 0 ] for s in shapes [ 1 :]: if s != shape : raise Exception ( f \"Inconsistent tomogram shapes of { shape } and { s } implied by .mod annotations.\" ) return shape __init__ ( filepath , annotations = None , * , load = True ) Initialize a TomogramFile instance. Parameters: filepath ( str ) \u2013 The file path to the tomogram file. annotations ( list of Annotation , default: None ) \u2013 Annotations corresponding to the tomogram. Defaults to None. load ( bool , default: True ) \u2013 Whether to load tomogram array data immediately. Defaults to True. If False, use self.load() when ready to load data. Source code in tomogram_datasets/tomogram.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def __init__ ( self , filepath : str , annotations : Optional [ List [ Annotation ]] = None , * , load : bool = True ): \"\"\"Initialize a TomogramFile instance. Args: filepath (str): The file path to the tomogram file. annotations (list of Annotation, optional): Annotations corresponding to the tomogram. Defaults to None. load (bool, optional): Whether to load tomogram array data immediately. Defaults to True. If False, use self.load() when ready to load data. \"\"\" self . data = None self . annotations = annotations self . filepath = filepath self . load_header () if load : self . load () get_data ( * , preprocess = True ) Access the data array in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array. Parameters: preprocess ( bool , default: True ) \u2013 Whether to preprocess the data after loading. Defaults to True. Returns: ndarray \u2013 The array data of the tomogram. In other words, returns the image. Source code in tomogram_datasets/tomogram.py 191 192 193 194 195 196 197 198 199 200 201 202 203 def get_data ( self , * , preprocess : bool = True ) -> np . ndarray : \"\"\" Access the data array in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The array data of the tomogram. In other words, returns the image. \"\"\" return self . load () get_shape ( * , preprocess = True ) Access the data array shape in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array shape. Parameters: preprocess ( bool , default: True ) \u2013 Whether to preprocess the data after loading. Defaults to True. Returns: ndarray \u2013 The data array shape of the tomogram. In other words, returns the ndarray \u2013 image's dimensions. Source code in tomogram_datasets/tomogram.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def get_shape ( self , * , preprocess : bool = True ) -> np . ndarray : \"\"\" Access the data array shape in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array shape. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The data array shape of the tomogram. In other words, returns the image's dimensions. \"\"\" return self . shape get_shape_from_annotations () Returns the shape of the tomogram without having to load it using the annotations attatched to this tomogram, if any are AnnotationFiles. If no AnnotationFiles of .mod type are in self.annotations, raises an exception. Returns: ndarray \u2013 The shape of the tomogram as inferred from ndarray \u2013 self.annotations. Raises: Exception \u2013 If no AnnotationFile objects are in self.annotations. Exception \u2013 If there are multiple AnnotationFile objects in Source code in tomogram_datasets/tomogram.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 def get_shape_from_annotations ( self ) -> np . ndarray : \"\"\" Returns the shape of the tomogram without having to load it using the annotations attatched to this tomogram, if any are AnnotationFiles. If no AnnotationFiles of `.mod` type are in self.annotations, raises an exception. Returns: The shape of the tomogram as inferred from self.annotations. Raises: Exception: If no AnnotationFile objects are in self.annotations. Exception: If there are multiple AnnotationFile objects in self.annotations and they imply inconsistent shapes. \"\"\" shapes = [] for annotation in self . annotations : if isinstance ( annotation , AnnotationFile ) and annotation . extension == \".mod\" : shape = annotation . tomogram_shape_from_mod () shapes . append ( shape ) if len ( shapes ) == 0 : raise Exception ( \"No .mod annotations found. Cannot infer tomogram shape.\" ) elif len ( shapes ) == 1 : return shapes [ 0 ] else : # Confirm that all the shapes agree shape = shapes [ 0 ] for s in shapes [ 1 :]: if s != shape : raise Exception ( f \"Inconsistent tomogram shapes of { shape } and { s } implied by .mod annotations.\" ) return shape get_voxel_spacing () Uses .mrc file header information to find the voxel spacing of this tomogram in \u00c5ngstroms. Returns: \u2013 Either an integer (if the voxel spacing is isotropic, i.e., the same \u2013 in all directions), or a 3-tuple (if the spacing is anisotropic) \u2013 representing the voxel spacing in each direction. Raises: IOError \u2013 If the file type is not .mrc . Source code in tomogram_datasets/tomogram.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def get_voxel_spacing ( self ): \"\"\" Uses `.mrc` file header information to find the voxel spacing of this tomogram in \u00c5ngstroms. Returns: Either an integer (if the voxel spacing is isotropic, i.e., the same in all directions), or a 3-tuple (if the spacing is anisotropic) representing the voxel spacing in each direction. Raises: IOError: If the file type is not `.mrc`. \"\"\" # Determine file extension. root , extension = os . path . splitext ( self . filepath ) if extension not in [ \".mrc\" , \".rec\" ]: raise IOError ( \"Tomogram file must be .mrc to load the voxel spacing.\" ) mrc = mrcfile . open ( self . filepath , mode = 'r' , header_only = True ) spacing = mrc . voxel_size # Convert pesky np.recarray to a normal ndarray if isinstance ( spacing , np . recarray ): spacing = np . array ([ spacing . x . item (), spacing . y . item (), spacing . z . item ()]) # If the spacing is already a scalar, return it. if isinstance ( spacing , ( int , float )): return spacing # If it isn't, check if all the tuple values are the same. # If so, just return one. If not, return the whole tuple if spacing [ 0 ] == spacing [ 1 ] and spacing [ 0 ] == spacing [ 2 ]: return spacing [ 0 ] else : return spacing load ( * , preprocess = True ) Load the tomogram data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Parameters: preprocess ( bool , default: True ) \u2013 Whether to preprocess the data after loading. Defaults to True. Returns: \u2013 The loaded tomogram data. Raises: IOError \u2013 If the file type is not supported. Source code in tomogram_datasets/tomogram.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def load ( self , * , preprocess : bool = True ): \"\"\"Load the tomogram data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The loaded tomogram data. Raises: IOError: If the file type is not supported. \"\"\" if self . data is not None : return self . data # Determine how to load based on file extension. root , extension = os . path . splitext ( self . filepath ) if extension in [ \".mrc\" , \".rec\" ]: data = TomogramFile . mrc_to_np ( self . filepath ) elif extension == \".npy\" : data = np . load ( self . filepath ) else : raise IOError ( \"Tomogram file must be of type .mrc, .rec, or .npy.\" ) # Initialize Tomogram class super () . __init__ ( data , self . annotations ) if preprocess : self . process () return self . data load_header () Loads only tomogram header data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Returns: Union [ dict , recarray ] \u2013 The loaded tomogram header data. Raises: IOError \u2013 If the file type is not supported. Source code in tomogram_datasets/tomogram.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def load_header ( self ) -> Union [ dict , np . recarray ]: \"\"\"Loads only tomogram header data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Returns: The loaded tomogram header data. Raises: IOError: If the file type is not supported. \"\"\" # Determine how to load based on file extension. root , extension = os . path . splitext ( self . filepath ) if extension in [ \".mrc\" , \".rec\" ]: mrc = mrcfile . open ( self . filepath , header_only = True ) self . header = mrc . header # Shape seems backward because python convention is reverse of # FORTRAN convention. This is deliberate. self . shape = tuple ( self . header [ dim ] . item () for dim in [ 'nz' , 'ny' , 'nx' ]) mrc . close () elif extension == \".npy\" : self . header = dict () else : raise IOError ( \"Tomogram file must be of type .mrc, .rec, or .npy.\" ) return self . header mrc_to_np ( filepath ) staticmethod Convert a .mrc or .rec file to a numpy array. Parameters: filepath ( str ) \u2013 The file path to the .mrc or .rec file. Returns: ndarray \u2013 The data loaded as a numpy array. Source code in tomogram_datasets/tomogram.py 271 272 273 274 275 276 277 278 279 280 281 282 283 @staticmethod def mrc_to_np ( filepath : str ) -> np . ndarray : \"\"\"Convert a .mrc or .rec file to a numpy array. Args: filepath (str): The file path to the .mrc or .rec file. Returns: The data loaded as a numpy array. \"\"\" with mrcfile . open ( filepath , 'r' ) as mrc : data = mrc . data . astype ( np . float64 ) return data process () Process the tomogram to improve contrast using contrast stretching. This method applies contrast stretching to enhance the visibility of features in the tomogram. Returns: ndarray \u2013 The processed tomogram data. Source code in tomogram_datasets/tomogram.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 def process ( self ) -> np . ndarray : \"\"\"Process the tomogram to improve contrast using contrast stretching. This method applies contrast stretching to enhance the visibility of features in the tomogram. Returns: The processed tomogram data. \"\"\" # Contrast stretching p2 , p98 = np . percentile ( self . get_data (), ( 2 , 98 )) data_rescale = exposure . rescale_intensity ( self . get_data (), in_range = ( p2 , p98 )) self . data = data_rescale return self . get_data () reload () Reload the tomogram data from the file. This method reinitializes the tomogram data by loading it again from the specified file. If the data has already been loaded, access it with self.get_data(). Returns: ndarray \u2013 The reloaded tomogram data. Source code in tomogram_datasets/tomogram.py 300 301 302 303 304 305 306 307 308 309 310 311 def reload ( self ) -> np . ndarray : \"\"\"Reload the tomogram data from the file. This method reinitializes the tomogram data by loading it again from the specified file. If the data has already been loaded, access it with self.get_data(). Returns: The reloaded tomogram data. \"\"\" self . data = TomogramFile . mrc_to_np ( self . filepath ) return self . get_data () rescale ( array ) staticmethod Rescale array values to the range [0, 1]. Parameters: array ( ndarray ) \u2013 The array to be rescaled. Returns: ndarray \u2013 The rescaled array. Source code in tomogram_datasets/tomogram.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 @staticmethod def rescale ( array : np . ndarray ) -> np . ndarray : \"\"\"Rescale array values to the range [0, 1]. Args: array (numpy.ndarray): The array to be rescaled. Returns: The rescaled array. \"\"\" maximum = np . max ( array ) minimum = np . min ( array ) range_ = maximum - minimum return ( array - minimum ) / range_","title":"Tomogram"},{"location":"tomogram/#tomogram_datasets.tomogram.Tomogram","text":"Represents a tomogram. Has fields for tomogram data and shape, as well as any annotations corresponding to the tomogram, which are represented with the Annotation class. Attributes: annotations ( list of Annotation ) \u2013 Annotations corresponding to this tomogram. data ( ndarray ) \u2013 A 3-dimensional array containing the tomogram image. shape ( ndarray ) \u2013 A 3-element array representing the shape of the tomogram data. Source code in tomogram_datasets/tomogram.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class Tomogram : \"\"\"Represents a tomogram. Has fields for tomogram data and shape, as well as any annotations corresponding to the tomogram, which are represented with the Annotation class. Attributes: annotations (list of Annotation): Annotations corresponding to this tomogram. data (numpy.ndarray): A 3-dimensional array containing the tomogram image. shape (numpy.ndarray): A 3-element array representing the shape of the tomogram data. \"\"\" def __init__ ( self , data : np . ndarray , annotations : Optional [ List [ Annotation ]] = None ): \"\"\"Initialize a Tomogram instance. Args: data (numpy.ndarray): A 3-dimensional array containing the tomogram image. annotations (list of Annotation, optional): A list of annotations corresponding to the tomogram. Defaults to None. \"\"\" self . annotations = [] if annotations is None else annotations self . data = data self . shape = data . shape def add_annotation ( self , annotation : Annotation ): \"\"\"Add an annotation to the tomogram. Args: annotation (Annotation): An annotation object to be added to the tomogram's annotations. \"\"\" self . annotations . append ( annotation ) def annotation_points ( self , annotation_index : Optional [ int ] = None ): \"\"\"Get annotation points from the tomogram. Retrieves annotation points from a specific annotation if an index is provided, or all annotation points from all annotations if no index is given. Args: annotation_index (int, optional): The index of the annotation from which to retrieve points. If None, retrieves points from all annotations. Defaults to None. Returns: A list of points from the specified annotation or all annotations. \"\"\" if annotation_index is not None : return self . annotations [ annotation_index ] . points else : indices = range ( len ( self . annotations )) points = [] for index in indices : points += self . annotation_points ( index ) return points def get_data ( self ) -> np . ndarray : \"\"\"Access the data array in the tomogram. Returns: The array data of the tomogram. In other words, returns the image. \"\"\" return self . data","title":"Tomogram"},{"location":"tomogram/#tomogram_datasets.tomogram.Tomogram.__init__","text":"Initialize a Tomogram instance. Parameters: data ( ndarray ) \u2013 A 3-dimensional array containing the tomogram image. annotations ( list of Annotation , default: None ) \u2013 A list of annotations corresponding to the tomogram. Defaults to None. Source code in tomogram_datasets/tomogram.py 29 30 31 32 33 34 35 36 37 38 39 def __init__ ( self , data : np . ndarray , annotations : Optional [ List [ Annotation ]] = None ): \"\"\"Initialize a Tomogram instance. Args: data (numpy.ndarray): A 3-dimensional array containing the tomogram image. annotations (list of Annotation, optional): A list of annotations corresponding to the tomogram. Defaults to None. \"\"\" self . annotations = [] if annotations is None else annotations self . data = data self . shape = data . shape","title":"__init__"},{"location":"tomogram/#tomogram_datasets.tomogram.Tomogram.add_annotation","text":"Add an annotation to the tomogram. Parameters: annotation ( Annotation ) \u2013 An annotation object to be added to the tomogram's annotations. Source code in tomogram_datasets/tomogram.py 41 42 43 44 45 46 47 48 def add_annotation ( self , annotation : Annotation ): \"\"\"Add an annotation to the tomogram. Args: annotation (Annotation): An annotation object to be added to the tomogram's annotations. \"\"\" self . annotations . append ( annotation )","title":"add_annotation"},{"location":"tomogram/#tomogram_datasets.tomogram.Tomogram.annotation_points","text":"Get annotation points from the tomogram. Retrieves annotation points from a specific annotation if an index is provided, or all annotation points from all annotations if no index is given. Parameters: annotation_index ( int , default: None ) \u2013 The index of the annotation from which to retrieve points. If None, retrieves points from all annotations. Defaults to None. Returns: \u2013 A list of points from the specified annotation or all annotations. Source code in tomogram_datasets/tomogram.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def annotation_points ( self , annotation_index : Optional [ int ] = None ): \"\"\"Get annotation points from the tomogram. Retrieves annotation points from a specific annotation if an index is provided, or all annotation points from all annotations if no index is given. Args: annotation_index (int, optional): The index of the annotation from which to retrieve points. If None, retrieves points from all annotations. Defaults to None. Returns: A list of points from the specified annotation or all annotations. \"\"\" if annotation_index is not None : return self . annotations [ annotation_index ] . points else : indices = range ( len ( self . annotations )) points = [] for index in indices : points += self . annotation_points ( index ) return points","title":"annotation_points"},{"location":"tomogram/#tomogram_datasets.tomogram.Tomogram.get_data","text":"Access the data array in the tomogram. Returns: ndarray \u2013 The array data of the tomogram. In other words, returns the image. Source code in tomogram_datasets/tomogram.py 75 76 77 78 79 80 81 def get_data ( self ) -> np . ndarray : \"\"\"Access the data array in the tomogram. Returns: The array data of the tomogram. In other words, returns the image. \"\"\" return self . data","title":"get_data"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile","text":"Bases: Tomogram Represents a tomogram file. Extends the Tomogram class to handle file operations, including loading tomogram data from files of specific formats. Access the image data inside with get_data() . Attributes: filepath ( str ) \u2013 The file path to the tomogram file. annotations ( list of Annotation ) \u2013 Annotations corresponding to the tomogram. data ( ndarray ) \u2013 A 3-dimensional array containing the tomogram image. Source code in tomogram_datasets/tomogram.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 class TomogramFile ( Tomogram ): \"\"\"Represents a tomogram file. Extends the Tomogram class to handle file operations, including loading tomogram data from files of specific formats. Access the image data inside with `get_data()`. Attributes: filepath (str): The file path to the tomogram file. annotations (list of Annotation): Annotations corresponding to the tomogram. data (numpy.ndarray): A 3-dimensional array containing the tomogram image. header (dict or numpy.recarray) Other data related to the tomogram file. \"\"\" def __init__ ( self , filepath : str , annotations : Optional [ List [ Annotation ]] = None , * , load : bool = True ): \"\"\"Initialize a TomogramFile instance. Args: filepath (str): The file path to the tomogram file. annotations (list of Annotation, optional): Annotations corresponding to the tomogram. Defaults to None. load (bool, optional): Whether to load tomogram array data immediately. Defaults to True. If False, use self.load() when ready to load data. \"\"\" self . data = None self . annotations = annotations self . filepath = filepath self . load_header () if load : self . load () def load ( self , * , preprocess : bool = True ): \"\"\"Load the tomogram data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The loaded tomogram data. Raises: IOError: If the file type is not supported. \"\"\" if self . data is not None : return self . data # Determine how to load based on file extension. root , extension = os . path . splitext ( self . filepath ) if extension in [ \".mrc\" , \".rec\" ]: data = TomogramFile . mrc_to_np ( self . filepath ) elif extension == \".npy\" : data = np . load ( self . filepath ) else : raise IOError ( \"Tomogram file must be of type .mrc, .rec, or .npy.\" ) # Initialize Tomogram class super () . __init__ ( data , self . annotations ) if preprocess : self . process () return self . data def load_header ( self ) -> Union [ dict , np . recarray ]: \"\"\"Loads only tomogram header data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Returns: The loaded tomogram header data. Raises: IOError: If the file type is not supported. \"\"\" # Determine how to load based on file extension. root , extension = os . path . splitext ( self . filepath ) if extension in [ \".mrc\" , \".rec\" ]: mrc = mrcfile . open ( self . filepath , header_only = True ) self . header = mrc . header # Shape seems backward because python convention is reverse of # FORTRAN convention. This is deliberate. self . shape = tuple ( self . header [ dim ] . item () for dim in [ 'nz' , 'ny' , 'nx' ]) mrc . close () elif extension == \".npy\" : self . header = dict () else : raise IOError ( \"Tomogram file must be of type .mrc, .rec, or .npy.\" ) return self . header def get_data ( self , * , preprocess : bool = True ) -> np . ndarray : \"\"\" Access the data array in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The array data of the tomogram. In other words, returns the image. \"\"\" return self . load () def get_shape ( self , * , preprocess : bool = True ) -> np . ndarray : \"\"\" Access the data array shape in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array shape. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The data array shape of the tomogram. In other words, returns the image's dimensions. \"\"\" return self . shape def get_voxel_spacing ( self ): \"\"\" Uses `.mrc` file header information to find the voxel spacing of this tomogram in \u00c5ngstroms. Returns: Either an integer (if the voxel spacing is isotropic, i.e., the same in all directions), or a 3-tuple (if the spacing is anisotropic) representing the voxel spacing in each direction. Raises: IOError: If the file type is not `.mrc`. \"\"\" # Determine file extension. root , extension = os . path . splitext ( self . filepath ) if extension not in [ \".mrc\" , \".rec\" ]: raise IOError ( \"Tomogram file must be .mrc to load the voxel spacing.\" ) mrc = mrcfile . open ( self . filepath , mode = 'r' , header_only = True ) spacing = mrc . voxel_size # Convert pesky np.recarray to a normal ndarray if isinstance ( spacing , np . recarray ): spacing = np . array ([ spacing . x . item (), spacing . y . item (), spacing . z . item ()]) # If the spacing is already a scalar, return it. if isinstance ( spacing , ( int , float )): return spacing # If it isn't, check if all the tuple values are the same. # If so, just return one. If not, return the whole tuple if spacing [ 0 ] == spacing [ 1 ] and spacing [ 0 ] == spacing [ 2 ]: return spacing [ 0 ] else : return spacing @staticmethod def rescale ( array : np . ndarray ) -> np . ndarray : \"\"\"Rescale array values to the range [0, 1]. Args: array (numpy.ndarray): The array to be rescaled. Returns: The rescaled array. \"\"\" maximum = np . max ( array ) minimum = np . min ( array ) range_ = maximum - minimum return ( array - minimum ) / range_ @staticmethod def mrc_to_np ( filepath : str ) -> np . ndarray : \"\"\"Convert a .mrc or .rec file to a numpy array. Args: filepath (str): The file path to the .mrc or .rec file. Returns: The data loaded as a numpy array. \"\"\" with mrcfile . open ( filepath , 'r' ) as mrc : data = mrc . data . astype ( np . float64 ) return data def process ( self ) -> np . ndarray : \"\"\"Process the tomogram to improve contrast using contrast stretching. This method applies contrast stretching to enhance the visibility of features in the tomogram. Returns: The processed tomogram data. \"\"\" # Contrast stretching p2 , p98 = np . percentile ( self . get_data (), ( 2 , 98 )) data_rescale = exposure . rescale_intensity ( self . get_data (), in_range = ( p2 , p98 )) self . data = data_rescale return self . get_data () def reload ( self ) -> np . ndarray : \"\"\"Reload the tomogram data from the file. This method reinitializes the tomogram data by loading it again from the specified file. If the data has already been loaded, access it with self.get_data(). Returns: The reloaded tomogram data. \"\"\" self . data = TomogramFile . mrc_to_np ( self . filepath ) return self . get_data () def get_shape_from_annotations ( self ) -> np . ndarray : \"\"\" Returns the shape of the tomogram without having to load it using the annotations attatched to this tomogram, if any are AnnotationFiles. If no AnnotationFiles of `.mod` type are in self.annotations, raises an exception. Returns: The shape of the tomogram as inferred from self.annotations. Raises: Exception: If no AnnotationFile objects are in self.annotations. Exception: If there are multiple AnnotationFile objects in self.annotations and they imply inconsistent shapes. \"\"\" shapes = [] for annotation in self . annotations : if isinstance ( annotation , AnnotationFile ) and annotation . extension == \".mod\" : shape = annotation . tomogram_shape_from_mod () shapes . append ( shape ) if len ( shapes ) == 0 : raise Exception ( \"No .mod annotations found. Cannot infer tomogram shape.\" ) elif len ( shapes ) == 1 : return shapes [ 0 ] else : # Confirm that all the shapes agree shape = shapes [ 0 ] for s in shapes [ 1 :]: if s != shape : raise Exception ( f \"Inconsistent tomogram shapes of { shape } and { s } implied by .mod annotations.\" ) return shape","title":"TomogramFile"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.__init__","text":"Initialize a TomogramFile instance. Parameters: filepath ( str ) \u2013 The file path to the tomogram file. annotations ( list of Annotation , default: None ) \u2013 Annotations corresponding to the tomogram. Defaults to None. load ( bool , default: True ) \u2013 Whether to load tomogram array data immediately. Defaults to True. If False, use self.load() when ready to load data. Source code in tomogram_datasets/tomogram.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def __init__ ( self , filepath : str , annotations : Optional [ List [ Annotation ]] = None , * , load : bool = True ): \"\"\"Initialize a TomogramFile instance. Args: filepath (str): The file path to the tomogram file. annotations (list of Annotation, optional): Annotations corresponding to the tomogram. Defaults to None. load (bool, optional): Whether to load tomogram array data immediately. Defaults to True. If False, use self.load() when ready to load data. \"\"\" self . data = None self . annotations = annotations self . filepath = filepath self . load_header () if load : self . load ()","title":"__init__"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.get_data","text":"Access the data array in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array. Parameters: preprocess ( bool , default: True ) \u2013 Whether to preprocess the data after loading. Defaults to True. Returns: ndarray \u2013 The array data of the tomogram. In other words, returns the image. Source code in tomogram_datasets/tomogram.py 191 192 193 194 195 196 197 198 199 200 201 202 203 def get_data ( self , * , preprocess : bool = True ) -> np . ndarray : \"\"\" Access the data array in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The array data of the tomogram. In other words, returns the image. \"\"\" return self . load ()","title":"get_data"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.get_shape","text":"Access the data array shape in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array shape. Parameters: preprocess ( bool , default: True ) \u2013 Whether to preprocess the data after loading. Defaults to True. Returns: ndarray \u2013 The data array shape of the tomogram. In other words, returns the ndarray \u2013 image's dimensions. Source code in tomogram_datasets/tomogram.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def get_shape ( self , * , preprocess : bool = True ) -> np . ndarray : \"\"\" Access the data array shape in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array shape. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The data array shape of the tomogram. In other words, returns the image's dimensions. \"\"\" return self . shape","title":"get_shape"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.get_shape_from_annotations","text":"Returns the shape of the tomogram without having to load it using the annotations attatched to this tomogram, if any are AnnotationFiles. If no AnnotationFiles of .mod type are in self.annotations, raises an exception. Returns: ndarray \u2013 The shape of the tomogram as inferred from ndarray \u2013 self.annotations. Raises: Exception \u2013 If no AnnotationFile objects are in self.annotations. Exception \u2013 If there are multiple AnnotationFile objects in Source code in tomogram_datasets/tomogram.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 def get_shape_from_annotations ( self ) -> np . ndarray : \"\"\" Returns the shape of the tomogram without having to load it using the annotations attatched to this tomogram, if any are AnnotationFiles. If no AnnotationFiles of `.mod` type are in self.annotations, raises an exception. Returns: The shape of the tomogram as inferred from self.annotations. Raises: Exception: If no AnnotationFile objects are in self.annotations. Exception: If there are multiple AnnotationFile objects in self.annotations and they imply inconsistent shapes. \"\"\" shapes = [] for annotation in self . annotations : if isinstance ( annotation , AnnotationFile ) and annotation . extension == \".mod\" : shape = annotation . tomogram_shape_from_mod () shapes . append ( shape ) if len ( shapes ) == 0 : raise Exception ( \"No .mod annotations found. Cannot infer tomogram shape.\" ) elif len ( shapes ) == 1 : return shapes [ 0 ] else : # Confirm that all the shapes agree shape = shapes [ 0 ] for s in shapes [ 1 :]: if s != shape : raise Exception ( f \"Inconsistent tomogram shapes of { shape } and { s } implied by .mod annotations.\" ) return shape","title":"get_shape_from_annotations"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.get_voxel_spacing","text":"Uses .mrc file header information to find the voxel spacing of this tomogram in \u00c5ngstroms. Returns: \u2013 Either an integer (if the voxel spacing is isotropic, i.e., the same \u2013 in all directions), or a 3-tuple (if the spacing is anisotropic) \u2013 representing the voxel spacing in each direction. Raises: IOError \u2013 If the file type is not .mrc . Source code in tomogram_datasets/tomogram.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def get_voxel_spacing ( self ): \"\"\" Uses `.mrc` file header information to find the voxel spacing of this tomogram in \u00c5ngstroms. Returns: Either an integer (if the voxel spacing is isotropic, i.e., the same in all directions), or a 3-tuple (if the spacing is anisotropic) representing the voxel spacing in each direction. Raises: IOError: If the file type is not `.mrc`. \"\"\" # Determine file extension. root , extension = os . path . splitext ( self . filepath ) if extension not in [ \".mrc\" , \".rec\" ]: raise IOError ( \"Tomogram file must be .mrc to load the voxel spacing.\" ) mrc = mrcfile . open ( self . filepath , mode = 'r' , header_only = True ) spacing = mrc . voxel_size # Convert pesky np.recarray to a normal ndarray if isinstance ( spacing , np . recarray ): spacing = np . array ([ spacing . x . item (), spacing . y . item (), spacing . z . item ()]) # If the spacing is already a scalar, return it. if isinstance ( spacing , ( int , float )): return spacing # If it isn't, check if all the tuple values are the same. # If so, just return one. If not, return the whole tuple if spacing [ 0 ] == spacing [ 1 ] and spacing [ 0 ] == spacing [ 2 ]: return spacing [ 0 ] else : return spacing","title":"get_voxel_spacing"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.load","text":"Load the tomogram data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Parameters: preprocess ( bool , default: True ) \u2013 Whether to preprocess the data after loading. Defaults to True. Returns: \u2013 The loaded tomogram data. Raises: IOError \u2013 If the file type is not supported. Source code in tomogram_datasets/tomogram.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def load ( self , * , preprocess : bool = True ): \"\"\"Load the tomogram data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The loaded tomogram data. Raises: IOError: If the file type is not supported. \"\"\" if self . data is not None : return self . data # Determine how to load based on file extension. root , extension = os . path . splitext ( self . filepath ) if extension in [ \".mrc\" , \".rec\" ]: data = TomogramFile . mrc_to_np ( self . filepath ) elif extension == \".npy\" : data = np . load ( self . filepath ) else : raise IOError ( \"Tomogram file must be of type .mrc, .rec, or .npy.\" ) # Initialize Tomogram class super () . __init__ ( data , self . annotations ) if preprocess : self . process () return self . data","title":"load"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.load_header","text":"Loads only tomogram header data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Returns: Union [ dict , recarray ] \u2013 The loaded tomogram header data. Raises: IOError \u2013 If the file type is not supported. Source code in tomogram_datasets/tomogram.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def load_header ( self ) -> Union [ dict , np . recarray ]: \"\"\"Loads only tomogram header data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Returns: The loaded tomogram header data. Raises: IOError: If the file type is not supported. \"\"\" # Determine how to load based on file extension. root , extension = os . path . splitext ( self . filepath ) if extension in [ \".mrc\" , \".rec\" ]: mrc = mrcfile . open ( self . filepath , header_only = True ) self . header = mrc . header # Shape seems backward because python convention is reverse of # FORTRAN convention. This is deliberate. self . shape = tuple ( self . header [ dim ] . item () for dim in [ 'nz' , 'ny' , 'nx' ]) mrc . close () elif extension == \".npy\" : self . header = dict () else : raise IOError ( \"Tomogram file must be of type .mrc, .rec, or .npy.\" ) return self . header","title":"load_header"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.mrc_to_np","text":"Convert a .mrc or .rec file to a numpy array. Parameters: filepath ( str ) \u2013 The file path to the .mrc or .rec file. Returns: ndarray \u2013 The data loaded as a numpy array. Source code in tomogram_datasets/tomogram.py 271 272 273 274 275 276 277 278 279 280 281 282 283 @staticmethod def mrc_to_np ( filepath : str ) -> np . ndarray : \"\"\"Convert a .mrc or .rec file to a numpy array. Args: filepath (str): The file path to the .mrc or .rec file. Returns: The data loaded as a numpy array. \"\"\" with mrcfile . open ( filepath , 'r' ) as mrc : data = mrc . data . astype ( np . float64 ) return data","title":"mrc_to_np"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.process","text":"Process the tomogram to improve contrast using contrast stretching. This method applies contrast stretching to enhance the visibility of features in the tomogram. Returns: ndarray \u2013 The processed tomogram data. Source code in tomogram_datasets/tomogram.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 def process ( self ) -> np . ndarray : \"\"\"Process the tomogram to improve contrast using contrast stretching. This method applies contrast stretching to enhance the visibility of features in the tomogram. Returns: The processed tomogram data. \"\"\" # Contrast stretching p2 , p98 = np . percentile ( self . get_data (), ( 2 , 98 )) data_rescale = exposure . rescale_intensity ( self . get_data (), in_range = ( p2 , p98 )) self . data = data_rescale return self . get_data ()","title":"process"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.reload","text":"Reload the tomogram data from the file. This method reinitializes the tomogram data by loading it again from the specified file. If the data has already been loaded, access it with self.get_data(). Returns: ndarray \u2013 The reloaded tomogram data. Source code in tomogram_datasets/tomogram.py 300 301 302 303 304 305 306 307 308 309 310 311 def reload ( self ) -> np . ndarray : \"\"\"Reload the tomogram data from the file. This method reinitializes the tomogram data by loading it again from the specified file. If the data has already been loaded, access it with self.get_data(). Returns: The reloaded tomogram data. \"\"\" self . data = TomogramFile . mrc_to_np ( self . filepath ) return self . get_data ()","title":"reload"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.rescale","text":"Rescale array values to the range [0, 1]. Parameters: array ( ndarray ) \u2013 The array to be rescaled. Returns: ndarray \u2013 The rescaled array. Source code in tomogram_datasets/tomogram.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 @staticmethod def rescale ( array : np . ndarray ) -> np . ndarray : \"\"\"Rescale array values to the range [0, 1]. Args: array (numpy.ndarray): The array to be rescaled. Returns: The rescaled array. \"\"\" maximum = np . max ( array ) minimum = np . min ( array ) range_ = maximum - minimum return ( array - minimum ) / range_","title":"rescale"}]}