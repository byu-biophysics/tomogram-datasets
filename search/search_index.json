{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"tomogram_datasets Welcome to the documentation for the tomogram_datasets module. This module simplifies tasks dealing with tomograms and their respective annotations. In particular, it is useful in the BYU Biophysics Group as a tool to easily access tomograms on BYU's supercomputer (see Supercomputer Utils ). Installation Install with pip: pip install git+https://github.com/byu-biophysics/tomogram-datasets.git Quick Start Loading annotated tomograms While in a supercomputer session, load all tomograms with their respective annotations with the following code: from tomogram_datasets import get_fm_tomogram_set tomogram_set = get_fm_tomogram_set() # Returns an SCTomogramSet object. See \"Supercomputer Utils\" train_set = tomogram_set.get_public_tomograms() # These tomograms are publicly available. Most are also on the CryoET Data Portal test_set = tomogram_set.get_private_tomograms() # These tomograms are reserved for the test set on Kaggle. Sensitive data for tomogram in train_set: # train_set is a list of TomogramFile objects. See \"Tomograms\" # Access tomogram array shape as numpy array tomo_shape = tomogram.shape # Access tomogram array data as a numpy array tomo_data = tomogram.get_data() # Access all annotation points. They're all flagellar motors, since they came from get_fm_tomogram_set() tomo_annotation_points = tomogram.annotation_points() # Access all Annotation objects attached to this tomogram. tomo_annotations = tomogram.annotations Be aware that the first time get_fm_tomogram_set() is called, it may take a couple of minutes to find all of the tomograms (it tends to take no more than 30 seconds the second time). This is something that ought to be optimized in the future. Working with annotated tomograms in a Jupyter notebook Paired with visualize_voxels , one can analyze our tomograms within the convenience of a Python Jupyter notebook. The following code loads our public tomograms, singles out those with more than four annotation points (flagellar motors, in this case), and displays the tomogram with the annotation points plotted in the tomogram. from tomogram_datasets import get_fm_tomogram_set from visualize_voxels import visualize # Load tomograms tomogram_set = get_fm_tomogram_set() train_set = tomogram_set.get_public_tomograms() # Find tomograms with more than four annotation points (motors) tomograms_with_motors = [tomo for tomo in train_set if tomo.annotations is not None] tomograms_with_many_motors = [tomo for tomo in tomograms_with_motors if len(tomo.annotation_points()) > 4] # Get a quick visualization the last tomogram found with more than four motors along with the motor locations tomogram_to_visualize = tomograms_with_many_motors[-1] motors = tomogram_to_visualize.annotation_points() # This may take a moment, since it has to load the tomogram's array data visualize(tomogram_to_visualize.get_data(), marks=motors) # One way to get a more exciting visualization visualize( # TomogramFile.get_data() yields a numpy array. In get_data, set preprocess=False for faster loading but a very poor visualization tomogram_to_visualize.get_data(), # Save as lots_of_motors.gif 'lots_of_motors.gif', # Points to mark in the visualization marks = motors, # Plot 150 of the layers in the tomogram, evenly spaced slices=150, # Display at 15 frames per second fps=15, # Set the title title=f'{len(motors)} flagellar motors!' ) The last cell above yields the following visualization, which one can pause and move frame-by-frame interactively in a Jupyter notebook. Usage Basic file loading Loading a tomogram Assume a tomogram is located at /tmp/tomogram-data/qya2015-11-19-2/atlas10003.mrc . Load it with path = \"/tmp/tomogram-data/qya2015-11-19-12/atlas3_at20002.mrc\" tomogram = TomogramFile(path) Supercomputer Utilities Assume a directory of directories (each of which potentially contains tomograms and annotations) is located in /tmp/tomogram-data . An example structure is shown below, in which some directories (the ones we really want to work with) contain a tomogram and an annotation. Others contain stuff we don't want, like \"PEET_FM\" below, or don't contain an annotation, like \"qya2015-11-19-16\". All of the directories contain at least some files we don't want. /tmp/tomogram-data \u251c\u2500\u2500 PEET_FM # Unwanted directory \u2502 \u251c\u2500\u2500 Run10 \u2502 \u2502 \u251c\u2500\u2500 averagedFilenames.txt \u2502 \u2502 \u251c\u2500\u2500 FM-001.log \u2502 \u2502 \u251c\u2500\u2500 FM-002.log \u2502 \u2502 \u251c\u2500\u2500 FM-003.log \u2502 \u2502 \u251c\u2500\u2500 FM-004.log \u2502 \u2502 \u251c\u2500\u2500 FM-005.log \u2502 \u2502 \u251c\u2500\u2500 FM-006.log \u2502 \u2502 \u251c\u2500\u2500 FM-007.log \u2502 \u22ee \u2502 \u22ee \u2502 \u22ee \u251c\u2500\u2500 qya2015-11-19-12 \u2502 \u251c\u2500\u2500 atlas3_at20002.mrc # File wanted! (tomogram) \u2502 \u251c\u2500\u2500 atlas3_at20002_part121_54.rec \u2502 \u2514\u2500\u2500 FM.mod # File wanted! (annotation) \u251c\u2500\u2500 qya2015-11-19-16 # No .mod file, directory not wanted! \u2502 \u251c\u2500\u2500 atlas40002.mrc # Would be wanted if it had an annotation \u2502 \u251c\u2500\u2500 atlas40002_part121_50.rec \u2502 \u2514\u2500\u2500 qya2015-11-19-16.id \u251c\u2500\u2500 qya2015-11-19-2 \u2502 \u251c\u2500\u2500 atlas10003.mrc # File wanted! (tomogram) \u2502 \u251c\u2500\u2500 atlas10003_part121_20.rec \u2502 \u251c\u2500\u2500 Fm.mod # File wanted! (annotation) \u2502 \u251c\u2500\u2500 FM.csv \u2502 \u2514\u2500\u2500 FMinitMOTL.csv \u2502 \u22ee \u2502 \u22ee \u2502 \u22ee Using the directory depicted above, here's one way to load all of the .mrc tomograms and automatically pair them with respective annotations: from tomogram_datasets import seek_dirs from tomogram_datasets import seek_annotated_tomos import re root = f\"/tmp/tomogram-data\" # `dir_regex should match the target directories (directories containing a tomogram and an annotation) within `root`. Often each of these matches represents a \"run\". dir_regex = re.compile(r\"qya\\d{4}.*\") # The directories I care about all start with 'qya' and four digits # `seek_dirs` returns a list of matching directories directories = seek_dirs(root, dir_regex) # flagellum_regex matches .mod files of the form `fm.mod`, ignoring case. flagellum_regex = re.compile(r\"^fm.mod$\", re.IGNORECASE) # tomogram_regex matches .rec files of the form `*.rec`. tomogram_regex = re.compile(r\".*\\.rec$\") # Look for tomograms in each of the directories targeted by `dir_regex` using the regexes defined above. tomograms = seek_annotated_tomos( directories, tomogram_regex, [flagellum_regex], [\"Flagellar Motor\"] ) Note: for memory efficiency, the data in the tomograms in tomograms are not loaded by default. To work with the ndarray within the tomograms in tomograms , first call load(), i.e., for the first tomogram in the list call tomograms[0].load() .","title":"tomogram_datasets"},{"location":"#tomogram_datasets","text":"Welcome to the documentation for the tomogram_datasets module. This module simplifies tasks dealing with tomograms and their respective annotations. In particular, it is useful in the BYU Biophysics Group as a tool to easily access tomograms on BYU's supercomputer (see Supercomputer Utils ).","title":"tomogram_datasets"},{"location":"#installation","text":"Install with pip: pip install git+https://github.com/byu-biophysics/tomogram-datasets.git","title":"Installation"},{"location":"#quick-start","text":"","title":"Quick Start"},{"location":"#loading-annotated-tomograms","text":"While in a supercomputer session, load all tomograms with their respective annotations with the following code: from tomogram_datasets import get_fm_tomogram_set tomogram_set = get_fm_tomogram_set() # Returns an SCTomogramSet object. See \"Supercomputer Utils\" train_set = tomogram_set.get_public_tomograms() # These tomograms are publicly available. Most are also on the CryoET Data Portal test_set = tomogram_set.get_private_tomograms() # These tomograms are reserved for the test set on Kaggle. Sensitive data for tomogram in train_set: # train_set is a list of TomogramFile objects. See \"Tomograms\" # Access tomogram array shape as numpy array tomo_shape = tomogram.shape # Access tomogram array data as a numpy array tomo_data = tomogram.get_data() # Access all annotation points. They're all flagellar motors, since they came from get_fm_tomogram_set() tomo_annotation_points = tomogram.annotation_points() # Access all Annotation objects attached to this tomogram. tomo_annotations = tomogram.annotations Be aware that the first time get_fm_tomogram_set() is called, it may take a couple of minutes to find all of the tomograms (it tends to take no more than 30 seconds the second time). This is something that ought to be optimized in the future.","title":"Loading annotated tomograms"},{"location":"#working-with-annotated-tomograms-in-a-jupyter-notebook","text":"Paired with visualize_voxels , one can analyze our tomograms within the convenience of a Python Jupyter notebook. The following code loads our public tomograms, singles out those with more than four annotation points (flagellar motors, in this case), and displays the tomogram with the annotation points plotted in the tomogram. from tomogram_datasets import get_fm_tomogram_set from visualize_voxels import visualize # Load tomograms tomogram_set = get_fm_tomogram_set() train_set = tomogram_set.get_public_tomograms() # Find tomograms with more than four annotation points (motors) tomograms_with_motors = [tomo for tomo in train_set if tomo.annotations is not None] tomograms_with_many_motors = [tomo for tomo in tomograms_with_motors if len(tomo.annotation_points()) > 4] # Get a quick visualization the last tomogram found with more than four motors along with the motor locations tomogram_to_visualize = tomograms_with_many_motors[-1] motors = tomogram_to_visualize.annotation_points() # This may take a moment, since it has to load the tomogram's array data visualize(tomogram_to_visualize.get_data(), marks=motors) # One way to get a more exciting visualization visualize( # TomogramFile.get_data() yields a numpy array. In get_data, set preprocess=False for faster loading but a very poor visualization tomogram_to_visualize.get_data(), # Save as lots_of_motors.gif 'lots_of_motors.gif', # Points to mark in the visualization marks = motors, # Plot 150 of the layers in the tomogram, evenly spaced slices=150, # Display at 15 frames per second fps=15, # Set the title title=f'{len(motors)} flagellar motors!' ) The last cell above yields the following visualization, which one can pause and move frame-by-frame interactively in a Jupyter notebook.","title":"Working with annotated tomograms in a Jupyter notebook"},{"location":"#usage","text":"","title":"Usage"},{"location":"#basic-file-loading","text":"","title":"Basic file loading"},{"location":"#loading-a-tomogram","text":"Assume a tomogram is located at /tmp/tomogram-data/qya2015-11-19-2/atlas10003.mrc . Load it with path = \"/tmp/tomogram-data/qya2015-11-19-12/atlas3_at20002.mrc\" tomogram = TomogramFile(path)","title":"Loading a tomogram"},{"location":"#supercomputer-utilities","text":"Assume a directory of directories (each of which potentially contains tomograms and annotations) is located in /tmp/tomogram-data . An example structure is shown below, in which some directories (the ones we really want to work with) contain a tomogram and an annotation. Others contain stuff we don't want, like \"PEET_FM\" below, or don't contain an annotation, like \"qya2015-11-19-16\". All of the directories contain at least some files we don't want. /tmp/tomogram-data \u251c\u2500\u2500 PEET_FM # Unwanted directory \u2502 \u251c\u2500\u2500 Run10 \u2502 \u2502 \u251c\u2500\u2500 averagedFilenames.txt \u2502 \u2502 \u251c\u2500\u2500 FM-001.log \u2502 \u2502 \u251c\u2500\u2500 FM-002.log \u2502 \u2502 \u251c\u2500\u2500 FM-003.log \u2502 \u2502 \u251c\u2500\u2500 FM-004.log \u2502 \u2502 \u251c\u2500\u2500 FM-005.log \u2502 \u2502 \u251c\u2500\u2500 FM-006.log \u2502 \u2502 \u251c\u2500\u2500 FM-007.log \u2502 \u22ee \u2502 \u22ee \u2502 \u22ee \u251c\u2500\u2500 qya2015-11-19-12 \u2502 \u251c\u2500\u2500 atlas3_at20002.mrc # File wanted! (tomogram) \u2502 \u251c\u2500\u2500 atlas3_at20002_part121_54.rec \u2502 \u2514\u2500\u2500 FM.mod # File wanted! (annotation) \u251c\u2500\u2500 qya2015-11-19-16 # No .mod file, directory not wanted! \u2502 \u251c\u2500\u2500 atlas40002.mrc # Would be wanted if it had an annotation \u2502 \u251c\u2500\u2500 atlas40002_part121_50.rec \u2502 \u2514\u2500\u2500 qya2015-11-19-16.id \u251c\u2500\u2500 qya2015-11-19-2 \u2502 \u251c\u2500\u2500 atlas10003.mrc # File wanted! (tomogram) \u2502 \u251c\u2500\u2500 atlas10003_part121_20.rec \u2502 \u251c\u2500\u2500 Fm.mod # File wanted! (annotation) \u2502 \u251c\u2500\u2500 FM.csv \u2502 \u2514\u2500\u2500 FMinitMOTL.csv \u2502 \u22ee \u2502 \u22ee \u2502 \u22ee Using the directory depicted above, here's one way to load all of the .mrc tomograms and automatically pair them with respective annotations: from tomogram_datasets import seek_dirs from tomogram_datasets import seek_annotated_tomos import re root = f\"/tmp/tomogram-data\" # `dir_regex should match the target directories (directories containing a tomogram and an annotation) within `root`. Often each of these matches represents a \"run\". dir_regex = re.compile(r\"qya\\d{4}.*\") # The directories I care about all start with 'qya' and four digits # `seek_dirs` returns a list of matching directories directories = seek_dirs(root, dir_regex) # flagellum_regex matches .mod files of the form `fm.mod`, ignoring case. flagellum_regex = re.compile(r\"^fm.mod$\", re.IGNORECASE) # tomogram_regex matches .rec files of the form `*.rec`. tomogram_regex = re.compile(r\".*\\.rec$\") # Look for tomograms in each of the directories targeted by `dir_regex` using the regexes defined above. tomograms = seek_annotated_tomos( directories, tomogram_regex, [flagellum_regex], [\"Flagellar Motor\"] ) Note: for memory efficiency, the data in the tomograms in tomograms are not loaded by default. To work with the ndarray within the tomograms in tomograms , first call load(), i.e., for the first tomogram in the list call tomograms[0].load() .","title":"Supercomputer Utilities"},{"location":"annotation/","text":"Annotations tomogram_datasets has two classes to represent a tomogram annotation\u2014 Annotation and AnnotationFile , which is a specific kind of annotation that comes from a file. Annotations tend to be accessed as attributes of Tomograms . The only annotations this package currently can parse from automatically from the supercomputer are flagellar motor annotations (see Supercomputer Utils , particularly get_fm_tomogram_set() , which automatically pairs flagellar annotations to their respective tomograms). See more details below. This module provides classes to work with tomogram annotations. Annotation This class represents a tomogram annotation. Attributes: points ( list of numpy.ndarray ) \u2013 Annnotation points name ( str ) \u2013 Name of this annotation Source code in tomogram_datasets/annotation.py 17 18 19 20 21 22 23 24 25 26 class Annotation : \"\"\"This class represents a tomogram annotation. Attributes: points (list of numpy.ndarray): Annnotation points name (str): Name of this annotation \"\"\" def __init__ ( self , points : List [ np . ndarray ], name : Optional [ str ] = None ): self . points = points self . name = \"\" if name is None else name AnnotationFile Bases: Annotation This class represents an annotation file. Extends the Annotation class to handle file operations, especially for .mod files. Attributes: filepath ( str ) \u2013 Filepath of this annotation file extension ( str ) \u2013 File extension of this annotation file df ( DataFrame ) \u2013 DataFrame of this file Source code in tomogram_datasets/annotation.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class AnnotationFile ( Annotation ): \"\"\"This class represents an annotation file. Extends the Annotation class to handle file operations, especially for .mod files. Attributes: filepath (str): Filepath of this annotation file extension (str): File extension of this annotation file df (pandas.DataFrame): DataFrame of this file \"\"\" def __init__ ( self , filepath : str , name : Optional [ str ] = None ): \"\"\"Initializes an AnnotationFile with a .mod file. Args: filepath (str): The filepath of the annotation to load name (str): The name of this annotation Raises: IOError: If the file extension is not .mod or .ndjson. \"\"\" self . filepath = filepath _ , extension = os . path . splitext ( filepath ) self . extension = extension if self . extension == \".mod\" : points = AnnotationFile . mod_points ( self . filepath ) elif self . extension == \".ndjson\" : points = AnnotationFile . ndjson_points ( self . filepath ) super () . __init__ ( points , name ) @staticmethod def check_ext ( filepath : str , ext : str ): \"\"\"Ensures that filepath is of a given type. Args: filepath (str): The file to check. ext (str): The desired file extension, i.e., \".mod\". Raises: IOError: If the file extension is not `ext`. \"\"\" _ , extension = os . path . splitext ( filepath ) if extension != ext : raise IOError ( f \"Annotation must be a { ext } file.\" ) @staticmethod def mod_to_pd ( filepath : str ) -> pd . DataFrame : \"\"\"Converts a .mod file to a pandas DataFrame. Args: filepath (str): File to convert. Returns: DataFrame of the annotation file with center_x, center_y, center_z renamed to x, y, z if annotation='slicer_angles'. Raises: IOError: If the file extension is not .mod. \"\"\" AnnotationFile . check_ext ( filepath , \".mod\" ) try : # First attempt with the 'annotation' parameter df = imodmodel . read ( filepath , annotation = 'slicer_angles' ) # Check if the relevant columns are present and rename them if all ( col in df . columns for col in [ 'center_x' , 'center_y' , 'center_z' ]): df = df . rename ( columns = { 'center_x' : 'x' , 'center_y' : 'y' , 'center_z' : 'z' }) return df except Exception as e : # Fallback attempt without the 'annotation' parameter return imodmodel . read ( filepath ) @staticmethod def mod_points ( filepath : str ) -> List [ np . ndarray ]: \"\"\"Reads a .mod file and extracts the points it contains. Args: filepath (str) Returns: List of points in the annotation file. \"\"\" df = AnnotationFile . mod_to_pd ( filepath ) points = [] for _ , row in df . iterrows (): # Assumes point is 3D dim_labels = [ 'x' , 'y' , 'z' ] point = np . array ([ row [ dim ] for dim in dim_labels ]) # The annotations seem to have been stored with this indexing. dims_order = [ 2 , 1 , 0 ] points . append ( point [ dims_order ]) return points @staticmethod def ndjson_points ( filepath : str ) -> List [ np . ndarray ]: \"\"\"Reads a .ndjson annotation file as stored on the CryoET Data Portal and extracts the points it contains. Args: filepath (str) Returns: List of points in the annotation file. \"\"\" points = [] with open ( filepath , 'r' ) as file : for line in file : data = json . loads ( line ) if data . get ( \"type\" ) == \"orientedPoint\" : location = data . get ( \"location\" ) if location : point = np . array ([ location [ \"z\" ], location [ \"x\" ], location [ \"y\" ]]) points . append ( point ) return points def tomogram_shape_from_mod ( self ): \"\"\" Finds the shape of the parent tomogram of this annotation, if this annotation is a `.mod` file. Returns: Shape of the parent tomogram. Raises: IOError: If this annotation is not a .mod file. \"\"\" AnnotationFile . check_ext ( self . filepath , \".mod\" ) header = ImodModel . from_file ( self . filepath ) . header return np . array ([ header . zmax , header . xmax , header . ymax ]) __init__ ( filepath , name = None ) Initializes an AnnotationFile with a .mod file. Parameters: filepath ( str ) \u2013 The filepath of the annotation to load name ( str , default: None ) \u2013 The name of this annotation Raises: IOError \u2013 If the file extension is not .mod or .ndjson. Source code in tomogram_datasets/annotation.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , filepath : str , name : Optional [ str ] = None ): \"\"\"Initializes an AnnotationFile with a .mod file. Args: filepath (str): The filepath of the annotation to load name (str): The name of this annotation Raises: IOError: If the file extension is not .mod or .ndjson. \"\"\" self . filepath = filepath _ , extension = os . path . splitext ( filepath ) self . extension = extension if self . extension == \".mod\" : points = AnnotationFile . mod_points ( self . filepath ) elif self . extension == \".ndjson\" : points = AnnotationFile . ndjson_points ( self . filepath ) super () . __init__ ( points , name ) check_ext ( filepath , ext ) staticmethod Ensures that filepath is of a given type. Parameters: filepath ( str ) \u2013 The file to check. ext ( str ) \u2013 The desired file extension, i.e., \".mod\". Raises: IOError \u2013 If the file extension is not ext . Source code in tomogram_datasets/annotation.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @staticmethod def check_ext ( filepath : str , ext : str ): \"\"\"Ensures that filepath is of a given type. Args: filepath (str): The file to check. ext (str): The desired file extension, i.e., \".mod\". Raises: IOError: If the file extension is not `ext`. \"\"\" _ , extension = os . path . splitext ( filepath ) if extension != ext : raise IOError ( f \"Annotation must be a { ext } file.\" ) mod_points ( filepath ) staticmethod Reads a .mod file and extracts the points it contains. Returns: List [ ndarray ] \u2013 List of points in the annotation file. Source code in tomogram_datasets/annotation.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 @staticmethod def mod_points ( filepath : str ) -> List [ np . ndarray ]: \"\"\"Reads a .mod file and extracts the points it contains. Args: filepath (str) Returns: List of points in the annotation file. \"\"\" df = AnnotationFile . mod_to_pd ( filepath ) points = [] for _ , row in df . iterrows (): # Assumes point is 3D dim_labels = [ 'x' , 'y' , 'z' ] point = np . array ([ row [ dim ] for dim in dim_labels ]) # The annotations seem to have been stored with this indexing. dims_order = [ 2 , 1 , 0 ] points . append ( point [ dims_order ]) return points mod_to_pd ( filepath ) staticmethod Converts a .mod file to a pandas DataFrame. Parameters: filepath ( str ) \u2013 File to convert. Returns: DataFrame \u2013 DataFrame of the annotation file with center_x, center_y, center_z renamed to DataFrame \u2013 x, y, z if annotation='slicer_angles'. Raises: IOError \u2013 If the file extension is not .mod. Source code in tomogram_datasets/annotation.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 @staticmethod def mod_to_pd ( filepath : str ) -> pd . DataFrame : \"\"\"Converts a .mod file to a pandas DataFrame. Args: filepath (str): File to convert. Returns: DataFrame of the annotation file with center_x, center_y, center_z renamed to x, y, z if annotation='slicer_angles'. Raises: IOError: If the file extension is not .mod. \"\"\" AnnotationFile . check_ext ( filepath , \".mod\" ) try : # First attempt with the 'annotation' parameter df = imodmodel . read ( filepath , annotation = 'slicer_angles' ) # Check if the relevant columns are present and rename them if all ( col in df . columns for col in [ 'center_x' , 'center_y' , 'center_z' ]): df = df . rename ( columns = { 'center_x' : 'x' , 'center_y' : 'y' , 'center_z' : 'z' }) return df except Exception as e : # Fallback attempt without the 'annotation' parameter return imodmodel . read ( filepath ) ndjson_points ( filepath ) staticmethod Reads a .ndjson annotation file as stored on the CryoET Data Portal and extracts the points it contains. Returns: List [ ndarray ] \u2013 List of points in the annotation file. Source code in tomogram_datasets/annotation.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 @staticmethod def ndjson_points ( filepath : str ) -> List [ np . ndarray ]: \"\"\"Reads a .ndjson annotation file as stored on the CryoET Data Portal and extracts the points it contains. Args: filepath (str) Returns: List of points in the annotation file. \"\"\" points = [] with open ( filepath , 'r' ) as file : for line in file : data = json . loads ( line ) if data . get ( \"type\" ) == \"orientedPoint\" : location = data . get ( \"location\" ) if location : point = np . array ([ location [ \"z\" ], location [ \"x\" ], location [ \"y\" ]]) points . append ( point ) return points tomogram_shape_from_mod () Finds the shape of the parent tomogram of this annotation, if this annotation is a .mod file. Returns: \u2013 Shape of the parent tomogram. Raises: IOError \u2013 If this annotation is not a .mod file. Source code in tomogram_datasets/annotation.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def tomogram_shape_from_mod ( self ): \"\"\" Finds the shape of the parent tomogram of this annotation, if this annotation is a `.mod` file. Returns: Shape of the parent tomogram. Raises: IOError: If this annotation is not a .mod file. \"\"\" AnnotationFile . check_ext ( self . filepath , \".mod\" ) header = ImodModel . from_file ( self . filepath ) . header return np . array ([ header . zmax , header . xmax , header . ymax ])","title":"Annotations"},{"location":"annotation/#annotations","text":"tomogram_datasets has two classes to represent a tomogram annotation\u2014 Annotation and AnnotationFile , which is a specific kind of annotation that comes from a file. Annotations tend to be accessed as attributes of Tomograms . The only annotations this package currently can parse from automatically from the supercomputer are flagellar motor annotations (see Supercomputer Utils , particularly get_fm_tomogram_set() , which automatically pairs flagellar annotations to their respective tomograms). See more details below. This module provides classes to work with tomogram annotations.","title":"Annotations"},{"location":"annotation/#tomogram_datasets.annotation.Annotation","text":"This class represents a tomogram annotation. Attributes: points ( list of numpy.ndarray ) \u2013 Annnotation points name ( str ) \u2013 Name of this annotation Source code in tomogram_datasets/annotation.py 17 18 19 20 21 22 23 24 25 26 class Annotation : \"\"\"This class represents a tomogram annotation. Attributes: points (list of numpy.ndarray): Annnotation points name (str): Name of this annotation \"\"\" def __init__ ( self , points : List [ np . ndarray ], name : Optional [ str ] = None ): self . points = points self . name = \"\" if name is None else name","title":"Annotation"},{"location":"annotation/#tomogram_datasets.annotation.AnnotationFile","text":"Bases: Annotation This class represents an annotation file. Extends the Annotation class to handle file operations, especially for .mod files. Attributes: filepath ( str ) \u2013 Filepath of this annotation file extension ( str ) \u2013 File extension of this annotation file df ( DataFrame ) \u2013 DataFrame of this file Source code in tomogram_datasets/annotation.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class AnnotationFile ( Annotation ): \"\"\"This class represents an annotation file. Extends the Annotation class to handle file operations, especially for .mod files. Attributes: filepath (str): Filepath of this annotation file extension (str): File extension of this annotation file df (pandas.DataFrame): DataFrame of this file \"\"\" def __init__ ( self , filepath : str , name : Optional [ str ] = None ): \"\"\"Initializes an AnnotationFile with a .mod file. Args: filepath (str): The filepath of the annotation to load name (str): The name of this annotation Raises: IOError: If the file extension is not .mod or .ndjson. \"\"\" self . filepath = filepath _ , extension = os . path . splitext ( filepath ) self . extension = extension if self . extension == \".mod\" : points = AnnotationFile . mod_points ( self . filepath ) elif self . extension == \".ndjson\" : points = AnnotationFile . ndjson_points ( self . filepath ) super () . __init__ ( points , name ) @staticmethod def check_ext ( filepath : str , ext : str ): \"\"\"Ensures that filepath is of a given type. Args: filepath (str): The file to check. ext (str): The desired file extension, i.e., \".mod\". Raises: IOError: If the file extension is not `ext`. \"\"\" _ , extension = os . path . splitext ( filepath ) if extension != ext : raise IOError ( f \"Annotation must be a { ext } file.\" ) @staticmethod def mod_to_pd ( filepath : str ) -> pd . DataFrame : \"\"\"Converts a .mod file to a pandas DataFrame. Args: filepath (str): File to convert. Returns: DataFrame of the annotation file with center_x, center_y, center_z renamed to x, y, z if annotation='slicer_angles'. Raises: IOError: If the file extension is not .mod. \"\"\" AnnotationFile . check_ext ( filepath , \".mod\" ) try : # First attempt with the 'annotation' parameter df = imodmodel . read ( filepath , annotation = 'slicer_angles' ) # Check if the relevant columns are present and rename them if all ( col in df . columns for col in [ 'center_x' , 'center_y' , 'center_z' ]): df = df . rename ( columns = { 'center_x' : 'x' , 'center_y' : 'y' , 'center_z' : 'z' }) return df except Exception as e : # Fallback attempt without the 'annotation' parameter return imodmodel . read ( filepath ) @staticmethod def mod_points ( filepath : str ) -> List [ np . ndarray ]: \"\"\"Reads a .mod file and extracts the points it contains. Args: filepath (str) Returns: List of points in the annotation file. \"\"\" df = AnnotationFile . mod_to_pd ( filepath ) points = [] for _ , row in df . iterrows (): # Assumes point is 3D dim_labels = [ 'x' , 'y' , 'z' ] point = np . array ([ row [ dim ] for dim in dim_labels ]) # The annotations seem to have been stored with this indexing. dims_order = [ 2 , 1 , 0 ] points . append ( point [ dims_order ]) return points @staticmethod def ndjson_points ( filepath : str ) -> List [ np . ndarray ]: \"\"\"Reads a .ndjson annotation file as stored on the CryoET Data Portal and extracts the points it contains. Args: filepath (str) Returns: List of points in the annotation file. \"\"\" points = [] with open ( filepath , 'r' ) as file : for line in file : data = json . loads ( line ) if data . get ( \"type\" ) == \"orientedPoint\" : location = data . get ( \"location\" ) if location : point = np . array ([ location [ \"z\" ], location [ \"x\" ], location [ \"y\" ]]) points . append ( point ) return points def tomogram_shape_from_mod ( self ): \"\"\" Finds the shape of the parent tomogram of this annotation, if this annotation is a `.mod` file. Returns: Shape of the parent tomogram. Raises: IOError: If this annotation is not a .mod file. \"\"\" AnnotationFile . check_ext ( self . filepath , \".mod\" ) header = ImodModel . from_file ( self . filepath ) . header return np . array ([ header . zmax , header . xmax , header . ymax ])","title":"AnnotationFile"},{"location":"annotation/#tomogram_datasets.annotation.AnnotationFile.__init__","text":"Initializes an AnnotationFile with a .mod file. Parameters: filepath ( str ) \u2013 The filepath of the annotation to load name ( str , default: None ) \u2013 The name of this annotation Raises: IOError \u2013 If the file extension is not .mod or .ndjson. Source code in tomogram_datasets/annotation.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , filepath : str , name : Optional [ str ] = None ): \"\"\"Initializes an AnnotationFile with a .mod file. Args: filepath (str): The filepath of the annotation to load name (str): The name of this annotation Raises: IOError: If the file extension is not .mod or .ndjson. \"\"\" self . filepath = filepath _ , extension = os . path . splitext ( filepath ) self . extension = extension if self . extension == \".mod\" : points = AnnotationFile . mod_points ( self . filepath ) elif self . extension == \".ndjson\" : points = AnnotationFile . ndjson_points ( self . filepath ) super () . __init__ ( points , name )","title":"__init__"},{"location":"annotation/#tomogram_datasets.annotation.AnnotationFile.check_ext","text":"Ensures that filepath is of a given type. Parameters: filepath ( str ) \u2013 The file to check. ext ( str ) \u2013 The desired file extension, i.e., \".mod\". Raises: IOError \u2013 If the file extension is not ext . Source code in tomogram_datasets/annotation.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @staticmethod def check_ext ( filepath : str , ext : str ): \"\"\"Ensures that filepath is of a given type. Args: filepath (str): The file to check. ext (str): The desired file extension, i.e., \".mod\". Raises: IOError: If the file extension is not `ext`. \"\"\" _ , extension = os . path . splitext ( filepath ) if extension != ext : raise IOError ( f \"Annotation must be a { ext } file.\" )","title":"check_ext"},{"location":"annotation/#tomogram_datasets.annotation.AnnotationFile.mod_points","text":"Reads a .mod file and extracts the points it contains. Returns: List [ ndarray ] \u2013 List of points in the annotation file. Source code in tomogram_datasets/annotation.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 @staticmethod def mod_points ( filepath : str ) -> List [ np . ndarray ]: \"\"\"Reads a .mod file and extracts the points it contains. Args: filepath (str) Returns: List of points in the annotation file. \"\"\" df = AnnotationFile . mod_to_pd ( filepath ) points = [] for _ , row in df . iterrows (): # Assumes point is 3D dim_labels = [ 'x' , 'y' , 'z' ] point = np . array ([ row [ dim ] for dim in dim_labels ]) # The annotations seem to have been stored with this indexing. dims_order = [ 2 , 1 , 0 ] points . append ( point [ dims_order ]) return points","title":"mod_points"},{"location":"annotation/#tomogram_datasets.annotation.AnnotationFile.mod_to_pd","text":"Converts a .mod file to a pandas DataFrame. Parameters: filepath ( str ) \u2013 File to convert. Returns: DataFrame \u2013 DataFrame of the annotation file with center_x, center_y, center_z renamed to DataFrame \u2013 x, y, z if annotation='slicer_angles'. Raises: IOError \u2013 If the file extension is not .mod. Source code in tomogram_datasets/annotation.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 @staticmethod def mod_to_pd ( filepath : str ) -> pd . DataFrame : \"\"\"Converts a .mod file to a pandas DataFrame. Args: filepath (str): File to convert. Returns: DataFrame of the annotation file with center_x, center_y, center_z renamed to x, y, z if annotation='slicer_angles'. Raises: IOError: If the file extension is not .mod. \"\"\" AnnotationFile . check_ext ( filepath , \".mod\" ) try : # First attempt with the 'annotation' parameter df = imodmodel . read ( filepath , annotation = 'slicer_angles' ) # Check if the relevant columns are present and rename them if all ( col in df . columns for col in [ 'center_x' , 'center_y' , 'center_z' ]): df = df . rename ( columns = { 'center_x' : 'x' , 'center_y' : 'y' , 'center_z' : 'z' }) return df except Exception as e : # Fallback attempt without the 'annotation' parameter return imodmodel . read ( filepath )","title":"mod_to_pd"},{"location":"annotation/#tomogram_datasets.annotation.AnnotationFile.ndjson_points","text":"Reads a .ndjson annotation file as stored on the CryoET Data Portal and extracts the points it contains. Returns: List [ ndarray ] \u2013 List of points in the annotation file. Source code in tomogram_datasets/annotation.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 @staticmethod def ndjson_points ( filepath : str ) -> List [ np . ndarray ]: \"\"\"Reads a .ndjson annotation file as stored on the CryoET Data Portal and extracts the points it contains. Args: filepath (str) Returns: List of points in the annotation file. \"\"\" points = [] with open ( filepath , 'r' ) as file : for line in file : data = json . loads ( line ) if data . get ( \"type\" ) == \"orientedPoint\" : location = data . get ( \"location\" ) if location : point = np . array ([ location [ \"z\" ], location [ \"x\" ], location [ \"y\" ]]) points . append ( point ) return points","title":"ndjson_points"},{"location":"annotation/#tomogram_datasets.annotation.AnnotationFile.tomogram_shape_from_mod","text":"Finds the shape of the parent tomogram of this annotation, if this annotation is a .mod file. Returns: \u2013 Shape of the parent tomogram. Raises: IOError \u2013 If this annotation is not a .mod file. Source code in tomogram_datasets/annotation.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def tomogram_shape_from_mod ( self ): \"\"\" Finds the shape of the parent tomogram of this annotation, if this annotation is a `.mod` file. Returns: Shape of the parent tomogram. Raises: IOError: If this annotation is not a .mod file. \"\"\" AnnotationFile . check_ext ( self . filepath , \".mod\" ) header = ImodModel . from_file ( self . filepath ) . header return np . array ([ header . zmax , header . xmax , header . ymax ])","title":"tomogram_shape_from_mod"},{"location":"subtomogram/","text":"Subtomograms Subtomogram Bases: Tomogram A class representing a subtomogram extracted from a parent tomogram. Attributes: parent_tomogram ( Tomogram ) \u2013 The tomogram from which this subtomogram was lower_bounds ( ndarray ) \u2013 The lower bounds of the subtomogram as they data ( ndarray ) \u2013 The 3D data of the subtomogram. shape ( ndarray ) \u2013 The shape of the subtomogram. Source code in tomogram_datasets/subtomogram.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class Subtomogram ( Tomogram ): \"\"\" A class representing a subtomogram extracted from a parent tomogram. Attributes: parent_tomogram (Tomogram): The tomogram from which this subtomogram was created. lower_bounds (np.ndarray): The lower bounds of the subtomogram as they would be indexed in the parent tomogram. data (np.ndarray): The 3D data of the subtomogram. shape (np.ndarray): The shape of the subtomogram. \"\"\" def __init__ ( self , parent_tomogram : 'Tomogram' , lower_bounds : np . ndarray , shape : np . ndarray ) -> None : \"\"\" Initializes a Subtomogram instance. Args: parent_tomogram (Tomogram): The parent tomogram. lower_bounds (np.ndarray): The lower bounds for the subtomogram. shape (np.ndarray): The shape of the subtomogram. \"\"\" self . parent_tomogram = parent_tomogram self . lower_bounds = lower_bounds # Modify annotations from the parent tomogram to match this tomogram new_annotations : List [ Annotation ] = [] for parent_annotation in self . parent_tomogram . annotations : new_points : List [ np . ndarray ] = [] # Offset original points for this new subtomogram for point in parent_annotation . points : new_point = point - lower_bounds # Check if new_point is even in the new tomogram if _in_bounds ( shape , new_point ): new_points . append ( new_point ) # Otherwise continue # Add the annotation only if there are points in it if len ( new_points ) > 0 : new_annotations . append ( Annotation ( new_points , parent_annotation . name )) # Get subvolume data using lower bounds and shape min_0 , min_1 , min_2 = lower_bounds shape_0 , shape_1 , shape_2 = shape new_data = parent_tomogram . data [ min_0 : min_0 + shape_0 , min_1 : min_1 + shape_1 , min_2 : min_2 + shape_2 ] # Initialize this new Tomogram super () . __init__ ( new_data , new_annotations ) __init__ ( parent_tomogram , lower_bounds , shape ) Initializes a Subtomogram instance. Parameters: parent_tomogram ( Tomogram ) \u2013 The parent tomogram. lower_bounds ( ndarray ) \u2013 The lower bounds for the subtomogram. shape ( ndarray ) \u2013 The shape of the subtomogram. Source code in tomogram_datasets/subtomogram.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , parent_tomogram : 'Tomogram' , lower_bounds : np . ndarray , shape : np . ndarray ) -> None : \"\"\" Initializes a Subtomogram instance. Args: parent_tomogram (Tomogram): The parent tomogram. lower_bounds (np.ndarray): The lower bounds for the subtomogram. shape (np.ndarray): The shape of the subtomogram. \"\"\" self . parent_tomogram = parent_tomogram self . lower_bounds = lower_bounds # Modify annotations from the parent tomogram to match this tomogram new_annotations : List [ Annotation ] = [] for parent_annotation in self . parent_tomogram . annotations : new_points : List [ np . ndarray ] = [] # Offset original points for this new subtomogram for point in parent_annotation . points : new_point = point - lower_bounds # Check if new_point is even in the new tomogram if _in_bounds ( shape , new_point ): new_points . append ( new_point ) # Otherwise continue # Add the annotation only if there are points in it if len ( new_points ) > 0 : new_annotations . append ( Annotation ( new_points , parent_annotation . name )) # Get subvolume data using lower bounds and shape min_0 , min_1 , min_2 = lower_bounds shape_0 , shape_1 , shape_2 = shape new_data = parent_tomogram . data [ min_0 : min_0 + shape_0 , min_1 : min_1 + shape_1 , min_2 : min_2 + shape_2 ] # Initialize this new Tomogram super () . __init__ ( new_data , new_annotations ) SubtomogramGenerator A class for generating subtomograms from a parent tomogram. Attributes: tomogram ( Tomogram ) \u2013 The parent tomogram to sample from. annotations ( List [ Annotation ] ) \u2013 The annotations from the parent vol_shape ( Tuple [ int , int , int ] ) \u2013 The shape of the volumes to be pads ( Tuple [ int , int , int ] ) \u2013 The padding to apply to the boundaries. gen ( Generator ) \u2013 Random number generator for sampling. Source code in tomogram_datasets/subtomogram.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class SubtomogramGenerator : \"\"\" A class for generating subtomograms from a parent tomogram. Attributes: tomogram (Tomogram): The parent tomogram to sample from. annotations (List[Annotation]): The annotations from the parent tomogram. vol_shape (Tuple[int, int, int]): The shape of the volumes to be generated. pads (Tuple[int, int, int]): The padding to apply to the boundaries. gen (np.random.Generator): Random number generator for sampling. \"\"\" def __init__ ( self , tomogram : 'Tomogram' ) -> None : \"\"\" Initializes a SubtomogramGenerator instance. Args: tomogram (Tomogram): The parent tomogram to sample from. \"\"\" self . tomogram = tomogram self . tomogram . load () self . annotations = self . tomogram . annotations self . vol_shape = ( 64 , 256 , 256 ) self . pads = ( 8 , 32 , 32 ) self . gen = np . random . default_rng () def set_vol_shape ( self , new_vol_shape : tuple [ int , int , int ]): \"\"\" Sets a new volume shape for the generator. Args: new_vol_shape (tuple[int, int, int]): The new volume shape. \"\"\" self . vol_shape = new_vol_shape def positive_sample ( self , point : Optional [ np . ndarray ] = None ) -> Subtomogram : \"\"\" Returns a random subtomogram containing the specified point. The point will not be closer than `pads` voxels to the respective borders. If no point is given, a random annotation point from self.tomogram's annotations is selected. Args: point (Optional[np.ndarray]): The point to include in the subtomogram. Defaults to None. Returns: The newly created subtomogram. \"\"\" if point is None : # Pick a random annotation point from self.tomogram's annotations annotation = self . gen . choice ( self . annotations ) point = self . gen . choice ( annotation . points ) possible_lower_bounds = [ np . linspace ( max ( 0 , pt - vs + pad ), min ( ts - vs , pt - pad ), endpoint = False , dtype = int ) for ( ts , vs , pt , pad ) in zip ( self . tomogram . shape , self . vol_shape , point , self . pads )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Construct a new Tomogram with modified annotations return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape ) def negative_sample ( self ) -> Subtomogram : \"\"\" Returns a random subtomogram that does not contain any points from the annotations. This process continues until a valid subtomogram is found or the maximum iterations are reached. Returns: The newly created subtomogram. Raises: Exception: If unable to find a valid subtomogram without annotation points after 1000 attempts. \"\"\" # Generate completely random bounds until one has no annotations maxiter = 1000 for iter in range ( maxiter ): possible_lower_bounds = [ np . linspace ( 0 , ts - vs , endpoint = False , dtype = int ) for ( ts , vs ) in zip ( self . tomogram . shape , self . vol_shape )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Check if this volume contains any annotation points contains_annotation = False for point in self . tomogram . annotation_points (): new_point = point - lower_bounds if _in_bounds ( self . vol_shape , new_point ): contains_annotation = True break if not contains_annotation : return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape ) raise Exception ( \"Failed to find a volume without an annotation\" ) def find_annotation_points ( self ) -> List [ np . ndarray ]: \"\"\" Returns a list of points that are present in the annotations. Returns: A list of annotation points. \"\"\" points : List [ np . ndarray ] = [] for annotation in self . annotations : points += annotation . points return points __init__ ( tomogram ) Initializes a SubtomogramGenerator instance. Parameters: tomogram ( Tomogram ) \u2013 The parent tomogram to sample from. Source code in tomogram_datasets/subtomogram.py 104 105 106 107 108 109 110 111 112 113 114 115 116 def __init__ ( self , tomogram : 'Tomogram' ) -> None : \"\"\" Initializes a SubtomogramGenerator instance. Args: tomogram (Tomogram): The parent tomogram to sample from. \"\"\" self . tomogram = tomogram self . tomogram . load () self . annotations = self . tomogram . annotations self . vol_shape = ( 64 , 256 , 256 ) self . pads = ( 8 , 32 , 32 ) self . gen = np . random . default_rng () find_annotation_points () Returns a list of points that are present in the annotations. Returns: List [ ndarray ] \u2013 A list of annotation points. Source code in tomogram_datasets/subtomogram.py 202 203 204 205 206 207 208 209 210 211 212 def find_annotation_points ( self ) -> List [ np . ndarray ]: \"\"\" Returns a list of points that are present in the annotations. Returns: A list of annotation points. \"\"\" points : List [ np . ndarray ] = [] for annotation in self . annotations : points += annotation . points return points negative_sample () Returns a random subtomogram that does not contain any points from the annotations. This process continues until a valid subtomogram is found or the maximum iterations are reached. Returns: Subtomogram \u2013 The newly created subtomogram. Raises: Exception \u2013 If unable to find a valid subtomogram without annotation Source code in tomogram_datasets/subtomogram.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def negative_sample ( self ) -> Subtomogram : \"\"\" Returns a random subtomogram that does not contain any points from the annotations. This process continues until a valid subtomogram is found or the maximum iterations are reached. Returns: The newly created subtomogram. Raises: Exception: If unable to find a valid subtomogram without annotation points after 1000 attempts. \"\"\" # Generate completely random bounds until one has no annotations maxiter = 1000 for iter in range ( maxiter ): possible_lower_bounds = [ np . linspace ( 0 , ts - vs , endpoint = False , dtype = int ) for ( ts , vs ) in zip ( self . tomogram . shape , self . vol_shape )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Check if this volume contains any annotation points contains_annotation = False for point in self . tomogram . annotation_points (): new_point = point - lower_bounds if _in_bounds ( self . vol_shape , new_point ): contains_annotation = True break if not contains_annotation : return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape ) raise Exception ( \"Failed to find a volume without an annotation\" ) positive_sample ( point = None ) Returns a random subtomogram containing the specified point. The point will not be closer than pads voxels to the respective borders. If no point is given, a random annotation point from self.tomogram's annotations is selected. Parameters: point ( Optional [ ndarray ] , default: None ) \u2013 The point to include in the Returns: Subtomogram \u2013 The newly created subtomogram. Source code in tomogram_datasets/subtomogram.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def positive_sample ( self , point : Optional [ np . ndarray ] = None ) -> Subtomogram : \"\"\" Returns a random subtomogram containing the specified point. The point will not be closer than `pads` voxels to the respective borders. If no point is given, a random annotation point from self.tomogram's annotations is selected. Args: point (Optional[np.ndarray]): The point to include in the subtomogram. Defaults to None. Returns: The newly created subtomogram. \"\"\" if point is None : # Pick a random annotation point from self.tomogram's annotations annotation = self . gen . choice ( self . annotations ) point = self . gen . choice ( annotation . points ) possible_lower_bounds = [ np . linspace ( max ( 0 , pt - vs + pad ), min ( ts - vs , pt - pad ), endpoint = False , dtype = int ) for ( ts , vs , pt , pad ) in zip ( self . tomogram . shape , self . vol_shape , point , self . pads )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Construct a new Tomogram with modified annotations return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape ) set_vol_shape ( new_vol_shape ) Sets a new volume shape for the generator. Parameters: new_vol_shape ( tuple [ int , int , int ] ) \u2013 The new volume shape. Source code in tomogram_datasets/subtomogram.py 118 119 120 121 122 123 124 125 def set_vol_shape ( self , new_vol_shape : tuple [ int , int , int ]): \"\"\" Sets a new volume shape for the generator. Args: new_vol_shape (tuple[int, int, int]): The new volume shape. \"\"\" self . vol_shape = new_vol_shape _in_bounds ( shape , point ) Checks if the point is within the bounds of an array with the given shape . Parameters: shape ( ndarray ) \u2013 The shape of the array. point (np.ndarray): The Returns: bool \u2013 True if the point is within bounds, False otherwise. Source code in tomogram_datasets/subtomogram.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def _in_bounds ( shape : np . ndarray , point : np . ndarray ) -> bool : \"\"\" Checks if the `point` is within the bounds of an array with the given `shape`. Args: shape (np.ndarray): The shape of the array. point (np.ndarray): The point to check. Returns: True if the point is within bounds, False otherwise. \"\"\" for ( s , p ) in zip ( shape , point ): if p < 0 or p >= s : return False return True","title":"Subtomograms"},{"location":"subtomogram/#subtomograms","text":"","title":"Subtomograms"},{"location":"subtomogram/#tomogram_datasets.subtomogram.Subtomogram","text":"Bases: Tomogram A class representing a subtomogram extracted from a parent tomogram. Attributes: parent_tomogram ( Tomogram ) \u2013 The tomogram from which this subtomogram was lower_bounds ( ndarray ) \u2013 The lower bounds of the subtomogram as they data ( ndarray ) \u2013 The 3D data of the subtomogram. shape ( ndarray ) \u2013 The shape of the subtomogram. Source code in tomogram_datasets/subtomogram.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class Subtomogram ( Tomogram ): \"\"\" A class representing a subtomogram extracted from a parent tomogram. Attributes: parent_tomogram (Tomogram): The tomogram from which this subtomogram was created. lower_bounds (np.ndarray): The lower bounds of the subtomogram as they would be indexed in the parent tomogram. data (np.ndarray): The 3D data of the subtomogram. shape (np.ndarray): The shape of the subtomogram. \"\"\" def __init__ ( self , parent_tomogram : 'Tomogram' , lower_bounds : np . ndarray , shape : np . ndarray ) -> None : \"\"\" Initializes a Subtomogram instance. Args: parent_tomogram (Tomogram): The parent tomogram. lower_bounds (np.ndarray): The lower bounds for the subtomogram. shape (np.ndarray): The shape of the subtomogram. \"\"\" self . parent_tomogram = parent_tomogram self . lower_bounds = lower_bounds # Modify annotations from the parent tomogram to match this tomogram new_annotations : List [ Annotation ] = [] for parent_annotation in self . parent_tomogram . annotations : new_points : List [ np . ndarray ] = [] # Offset original points for this new subtomogram for point in parent_annotation . points : new_point = point - lower_bounds # Check if new_point is even in the new tomogram if _in_bounds ( shape , new_point ): new_points . append ( new_point ) # Otherwise continue # Add the annotation only if there are points in it if len ( new_points ) > 0 : new_annotations . append ( Annotation ( new_points , parent_annotation . name )) # Get subvolume data using lower bounds and shape min_0 , min_1 , min_2 = lower_bounds shape_0 , shape_1 , shape_2 = shape new_data = parent_tomogram . data [ min_0 : min_0 + shape_0 , min_1 : min_1 + shape_1 , min_2 : min_2 + shape_2 ] # Initialize this new Tomogram super () . __init__ ( new_data , new_annotations )","title":"Subtomogram"},{"location":"subtomogram/#tomogram_datasets.subtomogram.Subtomogram.__init__","text":"Initializes a Subtomogram instance. Parameters: parent_tomogram ( Tomogram ) \u2013 The parent tomogram. lower_bounds ( ndarray ) \u2013 The lower bounds for the subtomogram. shape ( ndarray ) \u2013 The shape of the subtomogram. Source code in tomogram_datasets/subtomogram.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , parent_tomogram : 'Tomogram' , lower_bounds : np . ndarray , shape : np . ndarray ) -> None : \"\"\" Initializes a Subtomogram instance. Args: parent_tomogram (Tomogram): The parent tomogram. lower_bounds (np.ndarray): The lower bounds for the subtomogram. shape (np.ndarray): The shape of the subtomogram. \"\"\" self . parent_tomogram = parent_tomogram self . lower_bounds = lower_bounds # Modify annotations from the parent tomogram to match this tomogram new_annotations : List [ Annotation ] = [] for parent_annotation in self . parent_tomogram . annotations : new_points : List [ np . ndarray ] = [] # Offset original points for this new subtomogram for point in parent_annotation . points : new_point = point - lower_bounds # Check if new_point is even in the new tomogram if _in_bounds ( shape , new_point ): new_points . append ( new_point ) # Otherwise continue # Add the annotation only if there are points in it if len ( new_points ) > 0 : new_annotations . append ( Annotation ( new_points , parent_annotation . name )) # Get subvolume data using lower bounds and shape min_0 , min_1 , min_2 = lower_bounds shape_0 , shape_1 , shape_2 = shape new_data = parent_tomogram . data [ min_0 : min_0 + shape_0 , min_1 : min_1 + shape_1 , min_2 : min_2 + shape_2 ] # Initialize this new Tomogram super () . __init__ ( new_data , new_annotations )","title":"__init__"},{"location":"subtomogram/#tomogram_datasets.subtomogram.SubtomogramGenerator","text":"A class for generating subtomograms from a parent tomogram. Attributes: tomogram ( Tomogram ) \u2013 The parent tomogram to sample from. annotations ( List [ Annotation ] ) \u2013 The annotations from the parent vol_shape ( Tuple [ int , int , int ] ) \u2013 The shape of the volumes to be pads ( Tuple [ int , int , int ] ) \u2013 The padding to apply to the boundaries. gen ( Generator ) \u2013 Random number generator for sampling. Source code in tomogram_datasets/subtomogram.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 class SubtomogramGenerator : \"\"\" A class for generating subtomograms from a parent tomogram. Attributes: tomogram (Tomogram): The parent tomogram to sample from. annotations (List[Annotation]): The annotations from the parent tomogram. vol_shape (Tuple[int, int, int]): The shape of the volumes to be generated. pads (Tuple[int, int, int]): The padding to apply to the boundaries. gen (np.random.Generator): Random number generator for sampling. \"\"\" def __init__ ( self , tomogram : 'Tomogram' ) -> None : \"\"\" Initializes a SubtomogramGenerator instance. Args: tomogram (Tomogram): The parent tomogram to sample from. \"\"\" self . tomogram = tomogram self . tomogram . load () self . annotations = self . tomogram . annotations self . vol_shape = ( 64 , 256 , 256 ) self . pads = ( 8 , 32 , 32 ) self . gen = np . random . default_rng () def set_vol_shape ( self , new_vol_shape : tuple [ int , int , int ]): \"\"\" Sets a new volume shape for the generator. Args: new_vol_shape (tuple[int, int, int]): The new volume shape. \"\"\" self . vol_shape = new_vol_shape def positive_sample ( self , point : Optional [ np . ndarray ] = None ) -> Subtomogram : \"\"\" Returns a random subtomogram containing the specified point. The point will not be closer than `pads` voxels to the respective borders. If no point is given, a random annotation point from self.tomogram's annotations is selected. Args: point (Optional[np.ndarray]): The point to include in the subtomogram. Defaults to None. Returns: The newly created subtomogram. \"\"\" if point is None : # Pick a random annotation point from self.tomogram's annotations annotation = self . gen . choice ( self . annotations ) point = self . gen . choice ( annotation . points ) possible_lower_bounds = [ np . linspace ( max ( 0 , pt - vs + pad ), min ( ts - vs , pt - pad ), endpoint = False , dtype = int ) for ( ts , vs , pt , pad ) in zip ( self . tomogram . shape , self . vol_shape , point , self . pads )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Construct a new Tomogram with modified annotations return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape ) def negative_sample ( self ) -> Subtomogram : \"\"\" Returns a random subtomogram that does not contain any points from the annotations. This process continues until a valid subtomogram is found or the maximum iterations are reached. Returns: The newly created subtomogram. Raises: Exception: If unable to find a valid subtomogram without annotation points after 1000 attempts. \"\"\" # Generate completely random bounds until one has no annotations maxiter = 1000 for iter in range ( maxiter ): possible_lower_bounds = [ np . linspace ( 0 , ts - vs , endpoint = False , dtype = int ) for ( ts , vs ) in zip ( self . tomogram . shape , self . vol_shape )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Check if this volume contains any annotation points contains_annotation = False for point in self . tomogram . annotation_points (): new_point = point - lower_bounds if _in_bounds ( self . vol_shape , new_point ): contains_annotation = True break if not contains_annotation : return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape ) raise Exception ( \"Failed to find a volume without an annotation\" ) def find_annotation_points ( self ) -> List [ np . ndarray ]: \"\"\" Returns a list of points that are present in the annotations. Returns: A list of annotation points. \"\"\" points : List [ np . ndarray ] = [] for annotation in self . annotations : points += annotation . points return points","title":"SubtomogramGenerator"},{"location":"subtomogram/#tomogram_datasets.subtomogram.SubtomogramGenerator.__init__","text":"Initializes a SubtomogramGenerator instance. Parameters: tomogram ( Tomogram ) \u2013 The parent tomogram to sample from. Source code in tomogram_datasets/subtomogram.py 104 105 106 107 108 109 110 111 112 113 114 115 116 def __init__ ( self , tomogram : 'Tomogram' ) -> None : \"\"\" Initializes a SubtomogramGenerator instance. Args: tomogram (Tomogram): The parent tomogram to sample from. \"\"\" self . tomogram = tomogram self . tomogram . load () self . annotations = self . tomogram . annotations self . vol_shape = ( 64 , 256 , 256 ) self . pads = ( 8 , 32 , 32 ) self . gen = np . random . default_rng ()","title":"__init__"},{"location":"subtomogram/#tomogram_datasets.subtomogram.SubtomogramGenerator.find_annotation_points","text":"Returns a list of points that are present in the annotations. Returns: List [ ndarray ] \u2013 A list of annotation points. Source code in tomogram_datasets/subtomogram.py 202 203 204 205 206 207 208 209 210 211 212 def find_annotation_points ( self ) -> List [ np . ndarray ]: \"\"\" Returns a list of points that are present in the annotations. Returns: A list of annotation points. \"\"\" points : List [ np . ndarray ] = [] for annotation in self . annotations : points += annotation . points return points","title":"find_annotation_points"},{"location":"subtomogram/#tomogram_datasets.subtomogram.SubtomogramGenerator.negative_sample","text":"Returns a random subtomogram that does not contain any points from the annotations. This process continues until a valid subtomogram is found or the maximum iterations are reached. Returns: Subtomogram \u2013 The newly created subtomogram. Raises: Exception \u2013 If unable to find a valid subtomogram without annotation Source code in tomogram_datasets/subtomogram.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def negative_sample ( self ) -> Subtomogram : \"\"\" Returns a random subtomogram that does not contain any points from the annotations. This process continues until a valid subtomogram is found or the maximum iterations are reached. Returns: The newly created subtomogram. Raises: Exception: If unable to find a valid subtomogram without annotation points after 1000 attempts. \"\"\" # Generate completely random bounds until one has no annotations maxiter = 1000 for iter in range ( maxiter ): possible_lower_bounds = [ np . linspace ( 0 , ts - vs , endpoint = False , dtype = int ) for ( ts , vs ) in zip ( self . tomogram . shape , self . vol_shape )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Check if this volume contains any annotation points contains_annotation = False for point in self . tomogram . annotation_points (): new_point = point - lower_bounds if _in_bounds ( self . vol_shape , new_point ): contains_annotation = True break if not contains_annotation : return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape ) raise Exception ( \"Failed to find a volume without an annotation\" )","title":"negative_sample"},{"location":"subtomogram/#tomogram_datasets.subtomogram.SubtomogramGenerator.positive_sample","text":"Returns a random subtomogram containing the specified point. The point will not be closer than pads voxels to the respective borders. If no point is given, a random annotation point from self.tomogram's annotations is selected. Parameters: point ( Optional [ ndarray ] , default: None ) \u2013 The point to include in the Returns: Subtomogram \u2013 The newly created subtomogram. Source code in tomogram_datasets/subtomogram.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def positive_sample ( self , point : Optional [ np . ndarray ] = None ) -> Subtomogram : \"\"\" Returns a random subtomogram containing the specified point. The point will not be closer than `pads` voxels to the respective borders. If no point is given, a random annotation point from self.tomogram's annotations is selected. Args: point (Optional[np.ndarray]): The point to include in the subtomogram. Defaults to None. Returns: The newly created subtomogram. \"\"\" if point is None : # Pick a random annotation point from self.tomogram's annotations annotation = self . gen . choice ( self . annotations ) point = self . gen . choice ( annotation . points ) possible_lower_bounds = [ np . linspace ( max ( 0 , pt - vs + pad ), min ( ts - vs , pt - pad ), endpoint = False , dtype = int ) for ( ts , vs , pt , pad ) in zip ( self . tomogram . shape , self . vol_shape , point , self . pads )] lower_bounds = [ self . gen . choice ( lb , shuffle = False ) for lb in possible_lower_bounds ] # Construct a new Tomogram with modified annotations return Subtomogram ( self . tomogram , lower_bounds , self . vol_shape )","title":"positive_sample"},{"location":"subtomogram/#tomogram_datasets.subtomogram.SubtomogramGenerator.set_vol_shape","text":"Sets a new volume shape for the generator. Parameters: new_vol_shape ( tuple [ int , int , int ] ) \u2013 The new volume shape. Source code in tomogram_datasets/subtomogram.py 118 119 120 121 122 123 124 125 def set_vol_shape ( self , new_vol_shape : tuple [ int , int , int ]): \"\"\" Sets a new volume shape for the generator. Args: new_vol_shape (tuple[int, int, int]): The new volume shape. \"\"\" self . vol_shape = new_vol_shape","title":"set_vol_shape"},{"location":"subtomogram/#tomogram_datasets.subtomogram._in_bounds","text":"Checks if the point is within the bounds of an array with the given shape . Parameters: shape ( ndarray ) \u2013 The shape of the array. point (np.ndarray): The Returns: bool \u2013 True if the point is within bounds, False otherwise. Source code in tomogram_datasets/subtomogram.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def _in_bounds ( shape : np . ndarray , point : np . ndarray ) -> bool : \"\"\" Checks if the `point` is within the bounds of an array with the given `shape`. Args: shape (np.ndarray): The shape of the array. point (np.ndarray): The point to check. Returns: True if the point is within bounds, False otherwise. \"\"\" for ( s , p ) in zip ( shape , point ): if p < 0 or p >= s : return False return True","title":"_in_bounds"},{"location":"supercomputer_utils/","text":"Supercomputer Utils The functions described here tend to be useful when navigating the labyrinth that is our supercomputer to find tomograms and (for now) their associated flagellar motor annotations. get_fm_tomogram_set is particularly useful. It parses the supercomputer for the tomograms and annotations that essentially make up the dataset for the Kaggle competition we are launching. A collection of utilities for use on BYU's supercomputer. SCTomogramSet A class to manage the tomograms we work with on the supercomputer. Source code in tomogram_datasets/supercomputer_utils.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class SCTomogramSet (): \"\"\" A class to manage the tomograms we work with on the supercomputer. \"\"\" def __init__ ( self ): self . tomograms = dict () self . private = dict () def __repr__ ( self ): return f '<SCTomogramSet containing { len ( self . tomograms ) } tomograms>' def append ( self , new_tomogram : TomogramFile , private : bool ): \"\"\" Add a tomogram to the set. \"\"\" label = _get_label ( new_tomogram ) # If the tomogram isn't present, add it if label not in self . tomograms : self . tomograms [ label ] = new_tomogram self . private [ label ] = private # Otherwise, combine its annotations with the existing tomogram's # annotations. else : self . tomograms [ label ] = _combine_tomos ( self . tomograms [ label ], new_tomogram ) # If two matching tomograms have different privacy, make them both public if self . private [ label ] != private : self . private [ label ] = False def get_all_tomograms ( self ) -> List [ TomogramFile ]: \"\"\" Get all of the supercomputer tomograms. \"\"\" return self . tomogram . values () def get_private_tomograms ( self ) -> List [ TomogramFile ]: \"\"\" Get all of the private (test) supercomputer tomograms. \"\"\" requested_tomograms = [] for label in self . tomograms : if self . private [ label ]: requested_tomograms . append ( self . tomograms [ label ]) return requested_tomograms def get_public_tomograms ( self ) -> List [ TomogramFile ]: \"\"\" Get all of the public (train) supercomputer tomograms. \"\"\" requested_tomograms = [] for label in self . tomograms : if not self . private [ label ]: requested_tomograms . append ( self . tomograms [ label ]) return requested_tomograms append ( new_tomogram , private ) Add a tomogram to the set. Source code in tomogram_datasets/supercomputer_utils.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def append ( self , new_tomogram : TomogramFile , private : bool ): \"\"\" Add a tomogram to the set. \"\"\" label = _get_label ( new_tomogram ) # If the tomogram isn't present, add it if label not in self . tomograms : self . tomograms [ label ] = new_tomogram self . private [ label ] = private # Otherwise, combine its annotations with the existing tomogram's # annotations. else : self . tomograms [ label ] = _combine_tomos ( self . tomograms [ label ], new_tomogram ) # If two matching tomograms have different privacy, make them both public if self . private [ label ] != private : self . private [ label ] = False get_all_tomograms () Get all of the supercomputer tomograms. Source code in tomogram_datasets/supercomputer_utils.py 63 64 65 def get_all_tomograms ( self ) -> List [ TomogramFile ]: \"\"\" Get all of the supercomputer tomograms. \"\"\" return self . tomogram . values () get_private_tomograms () Get all of the private (test) supercomputer tomograms. Source code in tomogram_datasets/supercomputer_utils.py 66 67 68 69 70 71 72 def get_private_tomograms ( self ) -> List [ TomogramFile ]: \"\"\" Get all of the private (test) supercomputer tomograms. \"\"\" requested_tomograms = [] for label in self . tomograms : if self . private [ label ]: requested_tomograms . append ( self . tomograms [ label ]) return requested_tomograms get_public_tomograms () Get all of the public (train) supercomputer tomograms. Source code in tomogram_datasets/supercomputer_utils.py 73 74 75 76 77 78 79 def get_public_tomograms ( self ) -> List [ TomogramFile ]: \"\"\" Get all of the public (train) supercomputer tomograms. \"\"\" requested_tomograms = [] for label in self . tomograms : if not self . private [ label ]: requested_tomograms . append ( self . tomograms [ label ]) return requested_tomograms _combine_tomos ( tomo1 , tomo2 ) Combines two conceivably duplicate tomograms into one by merging their annotations. All other attributes are taken from tomo1 , like filepath and such. Source code in tomogram_datasets/supercomputer_utils.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def _combine_tomos ( tomo1 : TomogramFile , tomo2 : TomogramFile ) -> TomogramFile : \"\"\" Combines two conceivably duplicate tomograms into one by merging their annotations. All other attributes are taken from `tomo1`, like filepath and such. \"\"\" # Ensure that each tomogram has a list for its annotations, even if it is # empty if tomo1 . annotations is None : tomo1 . annotations = [] if tomo2 . annotations is None : tomo2 . annotations = [] # Combine annotations combined_annotations = tomo1 . annotations + tomo2 . annotations new_tomo = tomo1 new_tomo . annotations = combined_annotations # Choose shortest filepath new_tomo . filepath = min ( tomo1 . filepath , tomo2 . filepath , key = len ) return new_tomo _get_label ( tomo ) Tomogram \"labels\" are the filename without path nor extension. Source code in tomogram_datasets/supercomputer_utils.py 37 38 39 def _get_label ( tomo : TomogramFile ) -> str : \"\"\" Tomogram \"labels\" are the filename without path nor extension. \"\"\" return os . path . splitext ( os . path . basename ( tomo . filepath ))[ 0 ] get_fm_tomogram_set () Collect all tomograms that have been reviewed for flagellar motors from BYU's supercomputer into an SCTomogramSet. From an SCTomogramSet tomo_set , get public tomograms with tomo_set.get_public_tomograms() . Does not initially load the tomogram image data. Given a Tomogram called tomo , one can load and access the image data in one step with tomo.get_data() . Returns: SCTomogramSet \u2013 SCTomogramSet containing annotated tomograms Source code in tomogram_datasets/supercomputer_utils.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 def get_fm_tomogram_set () -> SCTomogramSet : \"\"\" Collect all tomograms that have been reviewed for flagellar motors from BYU's supercomputer into an SCTomogramSet. From an SCTomogramSet `tomo_set`, get public tomograms with `tomo_set.get_public_tomograms()`. Does not initially load the tomogram image data. Given a `Tomogram` called `tomo`, one can load and access the image data in one step with `tomo.get_data()`. Returns: SCTomogramSet containing annotated tomograms \"\"\" # Collect all tomograms together into an SCTomogramSet. tomogram_set = SCTomogramSet () tomograms = [] # A temporary list to collect tomograms. To be placed into the tomogram_set later. ### PUBLIC POSITIVES ### print ( f ' \\n Loading public positives. \\n\\t Current number of tomograms: { len ( tomogram_set . tomograms ) } \\n ' ) # ~~~ DRIVE 1 ~~~ # # Hylemonella root = f \"/grphome/grp_tomo_db1_d1/nobackup/archive/TomoDB1_d1/FlagellarMotor_P1/Hylemonella gracilis\" dir_regex = re . compile ( r \"yc\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^fm.mod$\" , re . IGNORECASE ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # ~~~ DRIVE 2 ~~~ # # Legionella root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/legionella\" dir_regex = re . compile ( r \"dg\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Pseudomonas root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/Pseudomonasaeruginosa/done\" dir_regex = re . compile ( r \"ab\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Proteus_mirabilis root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/Proteus_mirabilis\" dir_regex = re . compile ( r \"qya\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # ~~~ DRIVE 3 ~~~ # # Bdellovibrio root = f \"/grphome/grp_tomo_db1_d3/nobackup/archive/TomoDB1_d3/jhome_extra/Bdellovibrio_YW\" dir_regex = re . compile ( r \"yc\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^flagellum_SIRT_1k\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Azospirillum root = f \"/grphome/grp_tomo_db1_d3/nobackup/archive/TomoDB1_d3/jhome_extra/AzospirillumBrasilense/done\" dir_regex = re . compile ( r \"ab\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM3\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Add tomograms to `tomogram_set` and reset the temporary collection list `tomograms` for tomo in tomograms : tomogram_set . append ( tomo , private = False ) tomograms = [] print ( f 'Loading private positives. \\n\\t Current number of tomograms: { len ( tomogram_set . tomograms ) } \\n ' ) ### PRIVATE POSITIVES ### # ~~~ ZHIPING ~~~ # root = f \"/grphome/fslg_imagseg/nobackup/archive/zhiping_data/caulo_WT/\" dir_regex = re . compile ( r \"rrb\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^flagellum\\.mod$\" ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # ~~~ ANNOTATION PARTY ~~~ # root = f \"/grphome/grp_tomo_db1_d4/nobackup/archive/ExperimentRuns/\" dir_regex = re . compile ( r \"(sma\\d {4} .*)|(Vibrio.*)\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"flagellar_motor\\.mod\" ) tomogram_regex = re . compile ( r \".*\\.mrc$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Add tomograms to `tomogram_set` and reset the temporary collection list `tomograms` for tomo in tomograms : tomogram_set . append ( tomo , private = True ) tomograms = [] print ( f 'Loading public negatives. \\n\\t Current number of tomograms: { len ( tomogram_set . tomograms ) } \\n ' ) ### PUBLIC NEGATIVES ### # ~~~ DRIVE 1 ~~~ # # Hylemonella root = f \"/grphome/grp_tomo_db1_d1/nobackup/archive/TomoDB1_d1/FlagellarMotor_P1/Hylemonella gracilis\" dir_regex = re . compile ( r \"yc\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^fm.mod$\" , re . IGNORECASE ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # ~~~ DRIVE 2 ~~~ # # Legionella root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/legionella\" dir_regex = re . compile ( r \"dg\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # Pseudomonas root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/Pseudomonasaeruginosa/done\" dir_regex = re . compile ( r \"ab\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # Proteus_mirabilis root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/Proteus_mirabilis\" dir_regex = re . compile ( r \"qya\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # ~~~ DRIVE 3 ~~~ # # Bdellovibrio root = f \"/grphome/grp_tomo_db1_d3/nobackup/archive/TomoDB1_d3/jhome_extra/Bdellovibrio_YW\" dir_regex = re . compile ( r \"yc\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^flagellum_SIRT_1k\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # Azospirillum root = f \"/grphome/grp_tomo_db1_d3/nobackup/archive/TomoDB1_d3/jhome_extra/AzospirillumBrasilense/done\" dir_regex = re . compile ( r \"ab\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM3\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # Add tomograms to `tomogram_set` and reset the temporary collection list `tomograms` for tomo in tomograms : tomogram_set . append ( tomo , private = False ) tomograms = [] # ~~~ NEGATIVES BRAXTON FOUND ON RANDY DATA ~~~ # root = f \"/grphome/grp_tomo_db1_d3/nobackup/autodelete/negative_data\" these_tomograms = [ TomogramFile ( os . path . join ( root , path ), load = False ) for path in os . listdir ( root )] tomograms += these_tomograms print ( f 'Loading private negatives. \\n\\t Current number of tomograms: { len ( tomogram_set . tomograms ) } \\n ' ) ### PRIVATE NEGATIVES ### # ~~~ ZHIPING ~~~ # root = f \"/grphome/fslg_imagseg/nobackup/archive/zhiping_data/caulo_WT/\" dir_regex = re . compile ( r \"rrb\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^flagellum\\.mod$\" ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # ~~~ ANNOTATION PARTY ~~~ # root = f \"/grphome/grp_tomo_db1_d4/nobackup/archive/ExperimentRuns/\" dir_regex = re . compile ( r \"(sma\\d {4} .*)|(Vibrio.*)\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"flagellar_motor\\.mod\" ) tomogram_regex = re . compile ( r \".*\\.mrc$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # Add tomograms to `tomogram_set` and reset the temporary collection list `tomograms` for tomo in tomograms : tomogram_set . append ( tomo , private = True ) tomograms = [] print ( f 'Loading complete. \\n\\t Current number of tomograms: { len ( tomogram_set . tomograms ) } \\n ' ) # Return the completed set return tomogram_set seek_annotated_tomos ( directories , tomo_regex , annotation_regexes , annotation_names ) Collect pairs of tomogram files and their corresponding annotation files, without loading the tomograms. Expects one tomogram per directory. Parameters: directories ( list of str ) \u2013 List of directories to search for tomograms tomo_regex ( Pattern ) \u2013 The regex pattern to match tomogram filenames. annotation_regexes ( list of re.Pattern ) \u2013 A list of regex patterns to annotation_names ( list of str ) \u2013 A list of names for the annotations. Returns: List [ TomogramFile ] \u2013 TomogramFile objects with their corresponding annotations. Source code in tomogram_datasets/supercomputer_utils.py 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def seek_annotated_tomos ( directories : List [ str ], tomo_regex : re . Pattern , annotation_regexes : List [ re . Pattern ], annotation_names : List [ str ] ) -> List [ TomogramFile ]: \"\"\" Collect pairs of tomogram files and their corresponding annotation files, without loading the tomograms. Expects one tomogram per directory. Args: directories (list of str): List of directories to search for tomograms and annotations. tomo_regex (re.Pattern): The regex pattern to match tomogram filenames. annotation_regexes (list of re.Pattern): A list of regex patterns to match annotation filenames. annotation_names (list of str): A list of names for the annotations. Returns: TomogramFile objects with their corresponding annotations. \"\"\" tomos = [] for dir in directories : matches = seek_set ( dir , [ tomo_regex ] + annotation_regexes ) if matches is not None and None not in matches : tomogram_file = matches [ 0 ] annotation_files = matches [ 1 :] annotations = [] for ( file , name ) in zip ( annotation_files , annotation_names ): try : annotations . append ( AnnotationFile ( file , name )) except Exception as e : print ( f \"An exception occured while loading ` { file } `: \\n { e } \\n \" ) tomo = TomogramFile ( tomogram_file , annotations , load = False ) tomos . append ( tomo ) return tomos seek_dirs ( root , regex , directories = None ) Search for directories matching the given regex recursively within the specified root directory. Parameters: root ( str ) \u2013 The root directory to start the search. regex ( Pattern ) \u2013 The regex pattern to match the directory names. directories ( list , default: None ) \u2013 A list to accumulate matched directories. Returns: Union [ List [ str ], None] \u2013 A list of paths of matching directories. Source code in tomogram_datasets/supercomputer_utils.py 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 def seek_dirs ( root : str , regex : re . Pattern , directories : Optional [ List [ str ]] = None ) -> Union [ List [ str ], None ]: \"\"\"Search for directories matching the given regex recursively within the specified root directory. Args: root (str): The root directory to start the search. regex (re.Pattern): The regex pattern to match the directory names. directories (list, optional): A list to accumulate matched directories. Should not be set in general usage, as this is used only for internal recursion. Defaults to None. Returns: A list of paths of matching directories. \"\"\" if directories is None : directories = [] for this_root , dirs , _ in os . walk ( root ): for dir in dirs : if regex . match ( dir ): directories . append ( os . path . join ( this_root , dir )) else : directories = seek_dirs ( dir , regex , directories ) return directories seek_file ( directory , regex ) Search for a file matching the given regex recursively in the specified directory. Parameters: directory ( str ) \u2013 The root directory to start the search. regex regex ( Pattern ) \u2013 The regex pattern to match the filenames. Returns: Union [ str , None] \u2013 The full path of the matching file, or None if no match is Union [ str , None] \u2013 found. Source code in tomogram_datasets/supercomputer_utils.py 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 def seek_file ( directory : str , regex : re . Pattern ) -> Union [ str , None ]: \"\"\"Search for a file matching the given regex recursively in the specified directory. Args: directory (str): The root directory to start the search. regex regex (re.Pattern): The regex pattern to match the filenames. Returns: The full path of the matching file, or None if no match is found. \"\"\" for root , dirs , files in os . walk ( directory ): for file in files : if regex . match ( file ): return os . path . join ( root , file ) for dir in dirs : target = seek_file ( dir , regex ) if target is not None : return target return None seek_files ( directory , regex , files = None ) Search for all files matching the given regex recursively in the specified directory. Parameters: directory ( str ) \u2013 The root directory to start the search. regex ( Pattern ) \u2013 The regex pattern to match the filenames. files ( list , default: None ) \u2013 A list to accumulate matched files. Returns: List [ str ] \u2013 A list of the full paths of each matching file. Source code in tomogram_datasets/supercomputer_utils.py 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 def seek_files ( directory : str , regex : re . Pattern , files : Optional [ List [ str ]] = None ) -> List [ str ]: \"\"\"Search for all files matching the given regex recursively in the specified directory. Args: directory (str): The root directory to start the search. regex (re.Pattern): The regex pattern to match the filenames. files (list, optional): A list to accumulate matched files. Should not be set in general usage, as this is used only for internal recursion. Defaults to None. Returns: A list of the full paths of each matching file. \"\"\" if files is None : files = [] for root , dirs , dir_files in os . walk ( directory ): for dir_file in dir_files : if regex . match ( dir_file ): files . append ( os . path . join ( root , dir_file )) for dir in dirs : files = seek_files ( os . path . join ( root , dir ), regex , files ) return files seek_set ( directory , regexes , matches = None ) Recursively search the specified directory for exactly one match for each regex in the list. Parameters: directory ( str ) \u2013 The directory to search. regexes ( list of re.Pattern ) \u2013 A list of regex patterns to match filenames. matches ( list , default: None ) \u2013 A list to accumulate matches. Should not be Returns: Union [ List [ str ], None] \u2013 A list of matching file paths or None if extra matches are found. Source code in tomogram_datasets/supercomputer_utils.py 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 def seek_set ( directory : str , regexes : List [ re . Pattern ], matches : List [ str ] = None ) -> Union [ List [ str ], None ]: \"\"\"Recursively search the specified directory for exactly one match for each regex in the list. Args: directory (str): The directory to search. regexes (list of re.Pattern): A list of regex patterns to match filenames. matches (list, optional): A list to accumulate matches. Should not be set in general usage, as this is used only for internal recursion. Defaults to None. Returns: A list of matching file paths or None if extra matches are found. \"\"\" if matches is None : matches = [ None for _ in regexes ] for root , dirs , files in os . walk ( directory ): for file in files : for r_idx , r in enumerate ( regexes ): if re . match ( r , file ): if matches [ r_idx ] is None : matches [ r_idx ] = os . path . join ( root , file ) else : return None # Extra match found return matches seek_unannotated_tomos ( directories , tomo_regex , annotation_regexes ) Collect tomogram files that don't have annotations, without loading the tomograms. Parameters: directories ( list of str ) \u2013 List of directories to search for tomograms tomo_regex ( Pattern ) \u2013 The regex pattern to match tomogram filenames. annotation_regexes ( list of re.Pattern ) \u2013 A list of regex patterns. If Returns: List [ TomogramFile ] \u2013 TomogramFile objects. Source code in tomogram_datasets/supercomputer_utils.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 def seek_unannotated_tomos ( directories : List [ str ], tomo_regex : re . Pattern , annotation_regexes : List [ re . Pattern ], ) -> List [ TomogramFile ]: \"\"\" Collect tomogram files that don't have annotations, without loading the tomograms. Args: directories (list of str): List of directories to search for tomograms and annotations. tomo_regex (re.Pattern): The regex pattern to match tomogram filenames. annotation_regexes (list of re.Pattern): A list of regex patterns. If any of these patterns find a match for one of the files in a given directory in `directories`, the tomogram in that directory will not be saved and returned. Returns: TomogramFile objects. \"\"\" tomos = [] for dir in directories : matches = seek_set ( dir , [ tomo_regex ] + annotation_regexes ) if matches is not None and None not in matches : # This tomogram is annotated continue else : # Ensure that there is a tomogram in this directory tomo_candidates = seek_files ( dir , tomo_regex ) n_candidates = len ( tomo_candidates ) # If there are multiple possible unannotated tomogram candidates or # none here, that's an issue. if n_candidates > 1 : warnings . warn ( f \"Multiple ( { n_candidates } ) unannotated tomograms in { dir } found. This may mean that the regular expression used to seek tomograms is not specific enough, or that this directory is strange.\" ) continue elif n_candidates == 0 : warnings . warn ( f \"No tomograms found in { dir } .\" ) continue # If there is one candidate, it isn't annotated. else : # Append what must be the only unannotated tomogram candidate tomogram_file = tomo_candidates [ 0 ] tomo = TomogramFile ( tomogram_file , load = False ) tomos . append ( tomo ) return tomos","title":"Supercomputer Utils"},{"location":"supercomputer_utils/#supercomputer-utils","text":"The functions described here tend to be useful when navigating the labyrinth that is our supercomputer to find tomograms and (for now) their associated flagellar motor annotations. get_fm_tomogram_set is particularly useful. It parses the supercomputer for the tomograms and annotations that essentially make up the dataset for the Kaggle competition we are launching. A collection of utilities for use on BYU's supercomputer.","title":"Supercomputer Utils"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils.SCTomogramSet","text":"A class to manage the tomograms we work with on the supercomputer. Source code in tomogram_datasets/supercomputer_utils.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class SCTomogramSet (): \"\"\" A class to manage the tomograms we work with on the supercomputer. \"\"\" def __init__ ( self ): self . tomograms = dict () self . private = dict () def __repr__ ( self ): return f '<SCTomogramSet containing { len ( self . tomograms ) } tomograms>' def append ( self , new_tomogram : TomogramFile , private : bool ): \"\"\" Add a tomogram to the set. \"\"\" label = _get_label ( new_tomogram ) # If the tomogram isn't present, add it if label not in self . tomograms : self . tomograms [ label ] = new_tomogram self . private [ label ] = private # Otherwise, combine its annotations with the existing tomogram's # annotations. else : self . tomograms [ label ] = _combine_tomos ( self . tomograms [ label ], new_tomogram ) # If two matching tomograms have different privacy, make them both public if self . private [ label ] != private : self . private [ label ] = False def get_all_tomograms ( self ) -> List [ TomogramFile ]: \"\"\" Get all of the supercomputer tomograms. \"\"\" return self . tomogram . values () def get_private_tomograms ( self ) -> List [ TomogramFile ]: \"\"\" Get all of the private (test) supercomputer tomograms. \"\"\" requested_tomograms = [] for label in self . tomograms : if self . private [ label ]: requested_tomograms . append ( self . tomograms [ label ]) return requested_tomograms def get_public_tomograms ( self ) -> List [ TomogramFile ]: \"\"\" Get all of the public (train) supercomputer tomograms. \"\"\" requested_tomograms = [] for label in self . tomograms : if not self . private [ label ]: requested_tomograms . append ( self . tomograms [ label ]) return requested_tomograms","title":"SCTomogramSet"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils.SCTomogramSet.append","text":"Add a tomogram to the set. Source code in tomogram_datasets/supercomputer_utils.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def append ( self , new_tomogram : TomogramFile , private : bool ): \"\"\" Add a tomogram to the set. \"\"\" label = _get_label ( new_tomogram ) # If the tomogram isn't present, add it if label not in self . tomograms : self . tomograms [ label ] = new_tomogram self . private [ label ] = private # Otherwise, combine its annotations with the existing tomogram's # annotations. else : self . tomograms [ label ] = _combine_tomos ( self . tomograms [ label ], new_tomogram ) # If two matching tomograms have different privacy, make them both public if self . private [ label ] != private : self . private [ label ] = False","title":"append"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils.SCTomogramSet.get_all_tomograms","text":"Get all of the supercomputer tomograms. Source code in tomogram_datasets/supercomputer_utils.py 63 64 65 def get_all_tomograms ( self ) -> List [ TomogramFile ]: \"\"\" Get all of the supercomputer tomograms. \"\"\" return self . tomogram . values ()","title":"get_all_tomograms"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils.SCTomogramSet.get_private_tomograms","text":"Get all of the private (test) supercomputer tomograms. Source code in tomogram_datasets/supercomputer_utils.py 66 67 68 69 70 71 72 def get_private_tomograms ( self ) -> List [ TomogramFile ]: \"\"\" Get all of the private (test) supercomputer tomograms. \"\"\" requested_tomograms = [] for label in self . tomograms : if self . private [ label ]: requested_tomograms . append ( self . tomograms [ label ]) return requested_tomograms","title":"get_private_tomograms"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils.SCTomogramSet.get_public_tomograms","text":"Get all of the public (train) supercomputer tomograms. Source code in tomogram_datasets/supercomputer_utils.py 73 74 75 76 77 78 79 def get_public_tomograms ( self ) -> List [ TomogramFile ]: \"\"\" Get all of the public (train) supercomputer tomograms. \"\"\" requested_tomograms = [] for label in self . tomograms : if not self . private [ label ]: requested_tomograms . append ( self . tomograms [ label ]) return requested_tomograms","title":"get_public_tomograms"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils._combine_tomos","text":"Combines two conceivably duplicate tomograms into one by merging their annotations. All other attributes are taken from tomo1 , like filepath and such. Source code in tomogram_datasets/supercomputer_utils.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def _combine_tomos ( tomo1 : TomogramFile , tomo2 : TomogramFile ) -> TomogramFile : \"\"\" Combines two conceivably duplicate tomograms into one by merging their annotations. All other attributes are taken from `tomo1`, like filepath and such. \"\"\" # Ensure that each tomogram has a list for its annotations, even if it is # empty if tomo1 . annotations is None : tomo1 . annotations = [] if tomo2 . annotations is None : tomo2 . annotations = [] # Combine annotations combined_annotations = tomo1 . annotations + tomo2 . annotations new_tomo = tomo1 new_tomo . annotations = combined_annotations # Choose shortest filepath new_tomo . filepath = min ( tomo1 . filepath , tomo2 . filepath , key = len ) return new_tomo","title":"_combine_tomos"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils._get_label","text":"Tomogram \"labels\" are the filename without path nor extension. Source code in tomogram_datasets/supercomputer_utils.py 37 38 39 def _get_label ( tomo : TomogramFile ) -> str : \"\"\" Tomogram \"labels\" are the filename without path nor extension. \"\"\" return os . path . splitext ( os . path . basename ( tomo . filepath ))[ 0 ]","title":"_get_label"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils.get_fm_tomogram_set","text":"Collect all tomograms that have been reviewed for flagellar motors from BYU's supercomputer into an SCTomogramSet. From an SCTomogramSet tomo_set , get public tomograms with tomo_set.get_public_tomograms() . Does not initially load the tomogram image data. Given a Tomogram called tomo , one can load and access the image data in one step with tomo.get_data() . Returns: SCTomogramSet \u2013 SCTomogramSet containing annotated tomograms Source code in tomogram_datasets/supercomputer_utils.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 def get_fm_tomogram_set () -> SCTomogramSet : \"\"\" Collect all tomograms that have been reviewed for flagellar motors from BYU's supercomputer into an SCTomogramSet. From an SCTomogramSet `tomo_set`, get public tomograms with `tomo_set.get_public_tomograms()`. Does not initially load the tomogram image data. Given a `Tomogram` called `tomo`, one can load and access the image data in one step with `tomo.get_data()`. Returns: SCTomogramSet containing annotated tomograms \"\"\" # Collect all tomograms together into an SCTomogramSet. tomogram_set = SCTomogramSet () tomograms = [] # A temporary list to collect tomograms. To be placed into the tomogram_set later. ### PUBLIC POSITIVES ### print ( f ' \\n Loading public positives. \\n\\t Current number of tomograms: { len ( tomogram_set . tomograms ) } \\n ' ) # ~~~ DRIVE 1 ~~~ # # Hylemonella root = f \"/grphome/grp_tomo_db1_d1/nobackup/archive/TomoDB1_d1/FlagellarMotor_P1/Hylemonella gracilis\" dir_regex = re . compile ( r \"yc\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^fm.mod$\" , re . IGNORECASE ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # ~~~ DRIVE 2 ~~~ # # Legionella root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/legionella\" dir_regex = re . compile ( r \"dg\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Pseudomonas root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/Pseudomonasaeruginosa/done\" dir_regex = re . compile ( r \"ab\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Proteus_mirabilis root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/Proteus_mirabilis\" dir_regex = re . compile ( r \"qya\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # ~~~ DRIVE 3 ~~~ # # Bdellovibrio root = f \"/grphome/grp_tomo_db1_d3/nobackup/archive/TomoDB1_d3/jhome_extra/Bdellovibrio_YW\" dir_regex = re . compile ( r \"yc\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^flagellum_SIRT_1k\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Azospirillum root = f \"/grphome/grp_tomo_db1_d3/nobackup/archive/TomoDB1_d3/jhome_extra/AzospirillumBrasilense/done\" dir_regex = re . compile ( r \"ab\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM3\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Add tomograms to `tomogram_set` and reset the temporary collection list `tomograms` for tomo in tomograms : tomogram_set . append ( tomo , private = False ) tomograms = [] print ( f 'Loading private positives. \\n\\t Current number of tomograms: { len ( tomogram_set . tomograms ) } \\n ' ) ### PRIVATE POSITIVES ### # ~~~ ZHIPING ~~~ # root = f \"/grphome/fslg_imagseg/nobackup/archive/zhiping_data/caulo_WT/\" dir_regex = re . compile ( r \"rrb\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^flagellum\\.mod$\" ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # ~~~ ANNOTATION PARTY ~~~ # root = f \"/grphome/grp_tomo_db1_d4/nobackup/archive/ExperimentRuns/\" dir_regex = re . compile ( r \"(sma\\d {4} .*)|(Vibrio.*)\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"flagellar_motor\\.mod\" ) tomogram_regex = re . compile ( r \".*\\.mrc$\" ) these_tomograms = seek_annotated_tomos ( directories , tomogram_regex , [ flagellum_regex ], [ \"Flagellar Motor\" ] ) tomograms += these_tomograms # Add tomograms to `tomogram_set` and reset the temporary collection list `tomograms` for tomo in tomograms : tomogram_set . append ( tomo , private = True ) tomograms = [] print ( f 'Loading public negatives. \\n\\t Current number of tomograms: { len ( tomogram_set . tomograms ) } \\n ' ) ### PUBLIC NEGATIVES ### # ~~~ DRIVE 1 ~~~ # # Hylemonella root = f \"/grphome/grp_tomo_db1_d1/nobackup/archive/TomoDB1_d1/FlagellarMotor_P1/Hylemonella gracilis\" dir_regex = re . compile ( r \"yc\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^fm.mod$\" , re . IGNORECASE ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # ~~~ DRIVE 2 ~~~ # # Legionella root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/legionella\" dir_regex = re . compile ( r \"dg\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # Pseudomonas root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/Pseudomonasaeruginosa/done\" dir_regex = re . compile ( r \"ab\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # Proteus_mirabilis root = f \"/grphome/grp_tomo_db1_d2/nobackup/archive/TomoDB1_d2/FlagellarMotor_P2/Proteus_mirabilis\" dir_regex = re . compile ( r \"qya\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM\\.mod$\" ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # ~~~ DRIVE 3 ~~~ # # Bdellovibrio root = f \"/grphome/grp_tomo_db1_d3/nobackup/archive/TomoDB1_d3/jhome_extra/Bdellovibrio_YW\" dir_regex = re . compile ( r \"yc\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^flagellum_SIRT_1k\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # Azospirillum root = f \"/grphome/grp_tomo_db1_d3/nobackup/archive/TomoDB1_d3/jhome_extra/AzospirillumBrasilense/done\" dir_regex = re . compile ( r \"ab\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^FM3\\.mod$\" ) tomogram_regex = re . compile ( r \".*SIRT_1k\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # Add tomograms to `tomogram_set` and reset the temporary collection list `tomograms` for tomo in tomograms : tomogram_set . append ( tomo , private = False ) tomograms = [] # ~~~ NEGATIVES BRAXTON FOUND ON RANDY DATA ~~~ # root = f \"/grphome/grp_tomo_db1_d3/nobackup/autodelete/negative_data\" these_tomograms = [ TomogramFile ( os . path . join ( root , path ), load = False ) for path in os . listdir ( root )] tomograms += these_tomograms print ( f 'Loading private negatives. \\n\\t Current number of tomograms: { len ( tomogram_set . tomograms ) } \\n ' ) ### PRIVATE NEGATIVES ### # ~~~ ZHIPING ~~~ # root = f \"/grphome/fslg_imagseg/nobackup/archive/zhiping_data/caulo_WT/\" dir_regex = re . compile ( r \"rrb\\d {4} .*\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"^flagellum\\.mod$\" ) tomogram_regex = re . compile ( r \".*\\.rec$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # ~~~ ANNOTATION PARTY ~~~ # root = f \"/grphome/grp_tomo_db1_d4/nobackup/archive/ExperimentRuns/\" dir_regex = re . compile ( r \"(sma\\d {4} .*)|(Vibrio.*)\" ) directories = seek_dirs ( root , dir_regex ) flagellum_regex = re . compile ( r \"flagellar_motor\\.mod\" ) tomogram_regex = re . compile ( r \".*\\.mrc$\" ) these_tomograms = seek_unannotated_tomos ( directories , tomogram_regex , [ flagellum_regex ] ) tomograms += these_tomograms # Add tomograms to `tomogram_set` and reset the temporary collection list `tomograms` for tomo in tomograms : tomogram_set . append ( tomo , private = True ) tomograms = [] print ( f 'Loading complete. \\n\\t Current number of tomograms: { len ( tomogram_set . tomograms ) } \\n ' ) # Return the completed set return tomogram_set","title":"get_fm_tomogram_set"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils.seek_annotated_tomos","text":"Collect pairs of tomogram files and their corresponding annotation files, without loading the tomograms. Expects one tomogram per directory. Parameters: directories ( list of str ) \u2013 List of directories to search for tomograms tomo_regex ( Pattern ) \u2013 The regex pattern to match tomogram filenames. annotation_regexes ( list of re.Pattern ) \u2013 A list of regex patterns to annotation_names ( list of str ) \u2013 A list of names for the annotations. Returns: List [ TomogramFile ] \u2013 TomogramFile objects with their corresponding annotations. Source code in tomogram_datasets/supercomputer_utils.py 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def seek_annotated_tomos ( directories : List [ str ], tomo_regex : re . Pattern , annotation_regexes : List [ re . Pattern ], annotation_names : List [ str ] ) -> List [ TomogramFile ]: \"\"\" Collect pairs of tomogram files and their corresponding annotation files, without loading the tomograms. Expects one tomogram per directory. Args: directories (list of str): List of directories to search for tomograms and annotations. tomo_regex (re.Pattern): The regex pattern to match tomogram filenames. annotation_regexes (list of re.Pattern): A list of regex patterns to match annotation filenames. annotation_names (list of str): A list of names for the annotations. Returns: TomogramFile objects with their corresponding annotations. \"\"\" tomos = [] for dir in directories : matches = seek_set ( dir , [ tomo_regex ] + annotation_regexes ) if matches is not None and None not in matches : tomogram_file = matches [ 0 ] annotation_files = matches [ 1 :] annotations = [] for ( file , name ) in zip ( annotation_files , annotation_names ): try : annotations . append ( AnnotationFile ( file , name )) except Exception as e : print ( f \"An exception occured while loading ` { file } `: \\n { e } \\n \" ) tomo = TomogramFile ( tomogram_file , annotations , load = False ) tomos . append ( tomo ) return tomos","title":"seek_annotated_tomos"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils.seek_dirs","text":"Search for directories matching the given regex recursively within the specified root directory. Parameters: root ( str ) \u2013 The root directory to start the search. regex ( Pattern ) \u2013 The regex pattern to match the directory names. directories ( list , default: None ) \u2013 A list to accumulate matched directories. Returns: Union [ List [ str ], None] \u2013 A list of paths of matching directories. Source code in tomogram_datasets/supercomputer_utils.py 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 def seek_dirs ( root : str , regex : re . Pattern , directories : Optional [ List [ str ]] = None ) -> Union [ List [ str ], None ]: \"\"\"Search for directories matching the given regex recursively within the specified root directory. Args: root (str): The root directory to start the search. regex (re.Pattern): The regex pattern to match the directory names. directories (list, optional): A list to accumulate matched directories. Should not be set in general usage, as this is used only for internal recursion. Defaults to None. Returns: A list of paths of matching directories. \"\"\" if directories is None : directories = [] for this_root , dirs , _ in os . walk ( root ): for dir in dirs : if regex . match ( dir ): directories . append ( os . path . join ( this_root , dir )) else : directories = seek_dirs ( dir , regex , directories ) return directories","title":"seek_dirs"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils.seek_file","text":"Search for a file matching the given regex recursively in the specified directory. Parameters: directory ( str ) \u2013 The root directory to start the search. regex regex ( Pattern ) \u2013 The regex pattern to match the filenames. Returns: Union [ str , None] \u2013 The full path of the matching file, or None if no match is Union [ str , None] \u2013 found. Source code in tomogram_datasets/supercomputer_utils.py 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 def seek_file ( directory : str , regex : re . Pattern ) -> Union [ str , None ]: \"\"\"Search for a file matching the given regex recursively in the specified directory. Args: directory (str): The root directory to start the search. regex regex (re.Pattern): The regex pattern to match the filenames. Returns: The full path of the matching file, or None if no match is found. \"\"\" for root , dirs , files in os . walk ( directory ): for file in files : if regex . match ( file ): return os . path . join ( root , file ) for dir in dirs : target = seek_file ( dir , regex ) if target is not None : return target return None","title":"seek_file"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils.seek_files","text":"Search for all files matching the given regex recursively in the specified directory. Parameters: directory ( str ) \u2013 The root directory to start the search. regex ( Pattern ) \u2013 The regex pattern to match the filenames. files ( list , default: None ) \u2013 A list to accumulate matched files. Returns: List [ str ] \u2013 A list of the full paths of each matching file. Source code in tomogram_datasets/supercomputer_utils.py 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 def seek_files ( directory : str , regex : re . Pattern , files : Optional [ List [ str ]] = None ) -> List [ str ]: \"\"\"Search for all files matching the given regex recursively in the specified directory. Args: directory (str): The root directory to start the search. regex (re.Pattern): The regex pattern to match the filenames. files (list, optional): A list to accumulate matched files. Should not be set in general usage, as this is used only for internal recursion. Defaults to None. Returns: A list of the full paths of each matching file. \"\"\" if files is None : files = [] for root , dirs , dir_files in os . walk ( directory ): for dir_file in dir_files : if regex . match ( dir_file ): files . append ( os . path . join ( root , dir_file )) for dir in dirs : files = seek_files ( os . path . join ( root , dir ), regex , files ) return files","title":"seek_files"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils.seek_set","text":"Recursively search the specified directory for exactly one match for each regex in the list. Parameters: directory ( str ) \u2013 The directory to search. regexes ( list of re.Pattern ) \u2013 A list of regex patterns to match filenames. matches ( list , default: None ) \u2013 A list to accumulate matches. Should not be Returns: Union [ List [ str ], None] \u2013 A list of matching file paths or None if extra matches are found. Source code in tomogram_datasets/supercomputer_utils.py 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 def seek_set ( directory : str , regexes : List [ re . Pattern ], matches : List [ str ] = None ) -> Union [ List [ str ], None ]: \"\"\"Recursively search the specified directory for exactly one match for each regex in the list. Args: directory (str): The directory to search. regexes (list of re.Pattern): A list of regex patterns to match filenames. matches (list, optional): A list to accumulate matches. Should not be set in general usage, as this is used only for internal recursion. Defaults to None. Returns: A list of matching file paths or None if extra matches are found. \"\"\" if matches is None : matches = [ None for _ in regexes ] for root , dirs , files in os . walk ( directory ): for file in files : for r_idx , r in enumerate ( regexes ): if re . match ( r , file ): if matches [ r_idx ] is None : matches [ r_idx ] = os . path . join ( root , file ) else : return None # Extra match found return matches","title":"seek_set"},{"location":"supercomputer_utils/#tomogram_datasets.supercomputer_utils.seek_unannotated_tomos","text":"Collect tomogram files that don't have annotations, without loading the tomograms. Parameters: directories ( list of str ) \u2013 List of directories to search for tomograms tomo_regex ( Pattern ) \u2013 The regex pattern to match tomogram filenames. annotation_regexes ( list of re.Pattern ) \u2013 A list of regex patterns. If Returns: List [ TomogramFile ] \u2013 TomogramFile objects. Source code in tomogram_datasets/supercomputer_utils.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 def seek_unannotated_tomos ( directories : List [ str ], tomo_regex : re . Pattern , annotation_regexes : List [ re . Pattern ], ) -> List [ TomogramFile ]: \"\"\" Collect tomogram files that don't have annotations, without loading the tomograms. Args: directories (list of str): List of directories to search for tomograms and annotations. tomo_regex (re.Pattern): The regex pattern to match tomogram filenames. annotation_regexes (list of re.Pattern): A list of regex patterns. If any of these patterns find a match for one of the files in a given directory in `directories`, the tomogram in that directory will not be saved and returned. Returns: TomogramFile objects. \"\"\" tomos = [] for dir in directories : matches = seek_set ( dir , [ tomo_regex ] + annotation_regexes ) if matches is not None and None not in matches : # This tomogram is annotated continue else : # Ensure that there is a tomogram in this directory tomo_candidates = seek_files ( dir , tomo_regex ) n_candidates = len ( tomo_candidates ) # If there are multiple possible unannotated tomogram candidates or # none here, that's an issue. if n_candidates > 1 : warnings . warn ( f \"Multiple ( { n_candidates } ) unannotated tomograms in { dir } found. This may mean that the regular expression used to seek tomograms is not specific enough, or that this directory is strange.\" ) continue elif n_candidates == 0 : warnings . warn ( f \"No tomograms found in { dir } .\" ) continue # If there is one candidate, it isn't annotated. else : # Append what must be the only unannotated tomogram candidate tomogram_file = tomo_candidates [ 0 ] tomo = TomogramFile ( tomogram_file , load = False ) tomos . append ( tomo ) return tomos","title":"seek_unannotated_tomos"},{"location":"tomogram/","text":"Tomograms tomogram_datasets has two classes to represent a tomogram\u2014 Tomogram and TomogramFile , which is a specific kind of tomogram that comes from a file. One can load a tomogram from its filepath with tomogram = tomogram_datasets.Tomogram(filepath) , and get the tomogram's array data with tomogram.get_data() . Tomograms are often associated with Annotations in the Tomogram.annotations attribute. See more details below. Tomogram Represents a tomogram. Has fields for tomogram data and shape, as well as any annotations corresponding to the tomogram, which are represented with the Annotation class. Attributes: annotations ( list of Annotation ) \u2013 Annotations corresponding to this tomogram. data ( ndarray ) \u2013 A 3-dimensional array containing the tomogram image. shape ( ndarray ) \u2013 A 3-element array representing the shape of the tomogram data. Source code in tomogram_datasets/tomogram.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class Tomogram : \"\"\"Represents a tomogram. Has fields for tomogram data and shape, as well as any annotations corresponding to the tomogram, which are represented with the Annotation class. Attributes: annotations (list of Annotation): Annotations corresponding to this tomogram. data (numpy.ndarray): A 3-dimensional array containing the tomogram image. shape (numpy.ndarray): A 3-element array representing the shape of the tomogram data. \"\"\" def __init__ ( self , data : np . ndarray , annotations : Optional [ List [ Annotation ]] = None ): \"\"\"Initialize a Tomogram instance. Args: data (numpy.ndarray): A 3-dimensional array containing the tomogram image. annotations (list of Annotation, optional): A list of annotations corresponding to the tomogram. Defaults to None. \"\"\" self . annotations = [] if annotations is None else annotations self . data = data self . shape = data . shape def add_annotation ( self , annotation : Annotation ): \"\"\"Add an annotation to the tomogram. Args: annotation (Annotation): An annotation object to be added to the tomogram's annotations. \"\"\" self . annotations . append ( annotation ) def annotation_points ( self , annotation_index : Optional [ int ] = None ): \"\"\"Get annotation points from the tomogram. Retrieves annotation points from a specific annotation if an index is provided, or all annotation points from all annotations if no index is given. Args: annotation_index (int, optional): The index of the annotation from which to retrieve points. If None, retrieves points from all annotations. Defaults to None. Returns: A list of points from the specified annotation or all annotations. \"\"\" if annotation_index is not None : return self . annotations [ annotation_index ] . points else : indices = range ( len ( self . annotations )) points = [] for index in indices : points += self . annotation_points ( index ) return points def get_data ( self ) -> np . ndarray : \"\"\"Access the data array in the tomogram. Returns: The array data of the tomogram. In other words, returns the image. \"\"\" return self . data __init__ ( data , annotations = None ) Initialize a Tomogram instance. Parameters: data ( ndarray ) \u2013 A 3-dimensional array containing the tomogram image. annotations ( list of Annotation , default: None ) \u2013 A list of annotations corresponding to the tomogram. Defaults to None. Source code in tomogram_datasets/tomogram.py 29 30 31 32 33 34 35 36 37 38 39 def __init__ ( self , data : np . ndarray , annotations : Optional [ List [ Annotation ]] = None ): \"\"\"Initialize a Tomogram instance. Args: data (numpy.ndarray): A 3-dimensional array containing the tomogram image. annotations (list of Annotation, optional): A list of annotations corresponding to the tomogram. Defaults to None. \"\"\" self . annotations = [] if annotations is None else annotations self . data = data self . shape = data . shape add_annotation ( annotation ) Add an annotation to the tomogram. Parameters: annotation ( Annotation ) \u2013 An annotation object to be added to the tomogram's annotations. Source code in tomogram_datasets/tomogram.py 41 42 43 44 45 46 47 48 def add_annotation ( self , annotation : Annotation ): \"\"\"Add an annotation to the tomogram. Args: annotation (Annotation): An annotation object to be added to the tomogram's annotations. \"\"\" self . annotations . append ( annotation ) annotation_points ( annotation_index = None ) Get annotation points from the tomogram. Retrieves annotation points from a specific annotation if an index is provided, or all annotation points from all annotations if no index is given. Parameters: annotation_index ( int , default: None ) \u2013 The index of the annotation from which to retrieve points. If None, retrieves points from all annotations. Defaults to None. Returns: \u2013 A list of points from the specified annotation or all annotations. Source code in tomogram_datasets/tomogram.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def annotation_points ( self , annotation_index : Optional [ int ] = None ): \"\"\"Get annotation points from the tomogram. Retrieves annotation points from a specific annotation if an index is provided, or all annotation points from all annotations if no index is given. Args: annotation_index (int, optional): The index of the annotation from which to retrieve points. If None, retrieves points from all annotations. Defaults to None. Returns: A list of points from the specified annotation or all annotations. \"\"\" if annotation_index is not None : return self . annotations [ annotation_index ] . points else : indices = range ( len ( self . annotations )) points = [] for index in indices : points += self . annotation_points ( index ) return points get_data () Access the data array in the tomogram. Returns: ndarray \u2013 The array data of the tomogram. In other words, returns the image. Source code in tomogram_datasets/tomogram.py 75 76 77 78 79 80 81 def get_data ( self ) -> np . ndarray : \"\"\"Access the data array in the tomogram. Returns: The array data of the tomogram. In other words, returns the image. \"\"\" return self . data TomogramFile Bases: Tomogram Represents a tomogram file. Extends the Tomogram class to handle file operations, including loading tomogram data from files of specific formats. Access the image data inside with get_data() . Attributes: filepath ( str ) \u2013 The file path to the tomogram file. annotations ( list of Annotation ) \u2013 Annotations corresponding to the tomogram. data ( ndarray ) \u2013 A 3-dimensional array containing the tomogram image. Source code in tomogram_datasets/tomogram.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 class TomogramFile ( Tomogram ): \"\"\"Represents a tomogram file. Extends the Tomogram class to handle file operations, including loading tomogram data from files of specific formats. Access the image data inside with `get_data()`. Attributes: filepath (str): The file path to the tomogram file. annotations (list of Annotation): Annotations corresponding to the tomogram. data (numpy.ndarray): A 3-dimensional array containing the tomogram image. header (dict or numpy.recarray) Other data related to the tomogram file. \"\"\" def __init__ ( self , filepath : str , annotations : Optional [ List [ Annotation ]] = None , * , load : bool = True ): \"\"\"Initialize a TomogramFile instance. Args: filepath (str): The file path to the tomogram file. annotations (list of Annotation, optional): Annotations corresponding to the tomogram. Defaults to None. load (bool, optional): Whether to load tomogram array data immediately. Defaults to True. If False, use self.load() when ready to load data. \"\"\" self . data = None self . annotations = annotations self . filepath = filepath self . load_header () if load : self . load () def load ( self , * , preprocess : bool = True ): \"\"\"Load the tomogram data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The loaded tomogram data. Raises: IOError: If the file type is not supported. \"\"\" if self . data is not None : return self . data # Determine how to load based on file extension. root , extension = os . path . splitext ( self . filepath ) if extension in [ \".mrc\" , \".rec\" ]: data = TomogramFile . mrc_to_np ( self . filepath ) elif extension == \".npy\" : data = np . load ( self . filepath ) else : raise IOError ( \"Tomogram file must be of type .mrc, .rec, or .npy.\" ) # Initialize Tomogram class super () . __init__ ( data , self . annotations ) if preprocess : self . process () return self . data def load_header ( self ) -> Union [ dict , np . recarray ]: \"\"\"Loads only tomogram header data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Returns: The loaded tomogram header data. Raises: IOError: If the file type is not supported. \"\"\" # Determine how to load based on file extension. root , extension = os . path . splitext ( self . filepath ) if extension in [ \".mrc\" , \".rec\" ]: mrc = mrcfile . open ( self . filepath , header_only = True ) self . header = mrc . header # Shape seems backward because python convention is reverse of # FORTRAN convention. This is deliberate. self . shape = tuple ( self . header [ dim ] . item () for dim in [ 'nz' , 'ny' , 'nx' ]) mrc . close () elif extension == \".npy\" : self . header = dict () else : raise IOError ( \"Tomogram file must be of type .mrc, .rec, or .npy.\" ) return self . header def get_data ( self , * , preprocess : bool = True ) -> np . ndarray : \"\"\" Access the data array in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The array data of the tomogram. In other words, returns the image. \"\"\" return self . load ( preprocess = preprocess ) def get_shape ( self , * , preprocess : bool = True ) -> np . ndarray : \"\"\" Access the data array shape in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array shape. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The data array shape of the tomogram. In other words, returns the image's dimensions. \"\"\" return self . shape def get_voxel_spacing ( self ): \"\"\" Uses `.mrc` file header information to find the voxel spacing of this tomogram in \u00c5ngstroms. Returns: Either an integer (if the voxel spacing is isotropic, i.e., the same in all directions), or a 3-tuple (if the spacing is anisotropic) representing the voxel spacing in each direction. Raises: IOError: If the file type is not `.mrc`. \"\"\" # Determine file extension. root , extension = os . path . splitext ( self . filepath ) if extension not in [ \".mrc\" , \".rec\" ]: raise IOError ( \"Tomogram file must be .mrc to load the voxel spacing.\" ) mrc = mrcfile . open ( self . filepath , mode = 'r' , header_only = True ) spacing = mrc . voxel_size # Convert pesky np.recarray to a normal ndarray if isinstance ( spacing , np . recarray ): spacing = np . array ([ spacing . x . item (), spacing . y . item (), spacing . z . item ()]) # If the spacing is already a scalar, return it. if isinstance ( spacing , ( int , float )): return spacing # If it isn't, check if all the tuple values are the same. # If so, just return one. If not, return the whole tuple if spacing [ 0 ] == spacing [ 1 ] and spacing [ 0 ] == spacing [ 2 ]: return spacing [ 0 ] else : return spacing @staticmethod def rescale ( array : np . ndarray ) -> np . ndarray : \"\"\"Rescale array values to the range [0, 1]. Args: array (numpy.ndarray): The array to be rescaled. Returns: The rescaled array. \"\"\" maximum = np . max ( array ) minimum = np . min ( array ) range_ = maximum - minimum return ( array - minimum ) / range_ @staticmethod def mrc_to_np ( filepath : str ) -> np . ndarray : \"\"\"Convert a .mrc or .rec file to a numpy array. Args: filepath (str): The file path to the .mrc or .rec file. Returns: The data loaded as a numpy array. \"\"\" with mrcfile . open ( filepath , 'r' ) as mrc : data = mrc . data . astype ( np . float64 ) return data def process ( self ) -> np . ndarray : \"\"\"Process the tomogram to improve contrast using contrast stretching. This method applies contrast stretching to enhance the visibility of features in the tomogram. Returns: The processed tomogram data. \"\"\" # Contrast stretching p2 , p98 = np . percentile ( self . get_data (), ( 2 , 98 )) data_rescale = exposure . rescale_intensity ( self . get_data (), in_range = ( p2 , p98 )) self . data = data_rescale return self . get_data () def reload ( self ) -> np . ndarray : \"\"\"Reload the tomogram data from the file. This method reinitializes the tomogram data by loading it again from the specified file. If the data has already been loaded, access it with self.get_data(). Returns: The reloaded tomogram data. \"\"\" self . data = TomogramFile . mrc_to_np ( self . filepath ) return self . get_data () def get_shape_from_annotations ( self ) -> np . ndarray : \"\"\" Returns the shape of the tomogram without having to load it using the annotations attatched to this tomogram, if any are AnnotationFiles. If no AnnotationFiles of `.mod` type are in self.annotations, raises an exception. Returns: The shape of the tomogram as inferred from self.annotations. Raises: Exception: If no AnnotationFile objects are in self.annotations. Exception: If there are multiple AnnotationFile objects in self.annotations and they imply inconsistent shapes. \"\"\" shapes = [] for annotation in self . annotations : if isinstance ( annotation , AnnotationFile ) and annotation . extension == \".mod\" : shape = annotation . tomogram_shape_from_mod () shapes . append ( shape ) if len ( shapes ) == 0 : raise Exception ( \"No .mod annotations found. Cannot infer tomogram shape.\" ) elif len ( shapes ) == 1 : return shapes [ 0 ] else : # Confirm that all the shapes agree shape = shapes [ 0 ] for s in shapes [ 1 :]: if s != shape : raise Exception ( f \"Inconsistent tomogram shapes of { shape } and { s } implied by .mod annotations.\" ) return shape __init__ ( filepath , annotations = None , * , load = True ) Initialize a TomogramFile instance. Parameters: filepath ( str ) \u2013 The file path to the tomogram file. annotations ( list of Annotation , default: None ) \u2013 Annotations corresponding to the tomogram. Defaults to None. load ( bool , default: True ) \u2013 Whether to load tomogram array data immediately. Defaults to True. If False, use self.load() when ready to load data. Source code in tomogram_datasets/tomogram.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def __init__ ( self , filepath : str , annotations : Optional [ List [ Annotation ]] = None , * , load : bool = True ): \"\"\"Initialize a TomogramFile instance. Args: filepath (str): The file path to the tomogram file. annotations (list of Annotation, optional): Annotations corresponding to the tomogram. Defaults to None. load (bool, optional): Whether to load tomogram array data immediately. Defaults to True. If False, use self.load() when ready to load data. \"\"\" self . data = None self . annotations = annotations self . filepath = filepath self . load_header () if load : self . load () get_data ( * , preprocess = True ) Access the data array in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array. Parameters: preprocess ( bool , default: True ) \u2013 Whether to preprocess the data after loading. Defaults to True. Returns: ndarray \u2013 The array data of the tomogram. In other words, returns the image. Source code in tomogram_datasets/tomogram.py 191 192 193 194 195 196 197 198 199 200 201 202 203 def get_data ( self , * , preprocess : bool = True ) -> np . ndarray : \"\"\" Access the data array in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The array data of the tomogram. In other words, returns the image. \"\"\" return self . load ( preprocess = preprocess ) get_shape ( * , preprocess = True ) Access the data array shape in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array shape. Parameters: preprocess ( bool , default: True ) \u2013 Whether to preprocess the data after loading. Defaults to True. Returns: ndarray \u2013 The data array shape of the tomogram. In other words, returns the ndarray \u2013 image's dimensions. Source code in tomogram_datasets/tomogram.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def get_shape ( self , * , preprocess : bool = True ) -> np . ndarray : \"\"\" Access the data array shape in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array shape. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The data array shape of the tomogram. In other words, returns the image's dimensions. \"\"\" return self . shape get_shape_from_annotations () Returns the shape of the tomogram without having to load it using the annotations attatched to this tomogram, if any are AnnotationFiles. If no AnnotationFiles of .mod type are in self.annotations, raises an exception. Returns: ndarray \u2013 The shape of the tomogram as inferred from ndarray \u2013 self.annotations. Raises: Exception \u2013 If no AnnotationFile objects are in self.annotations. Exception \u2013 If there are multiple AnnotationFile objects in Source code in tomogram_datasets/tomogram.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 def get_shape_from_annotations ( self ) -> np . ndarray : \"\"\" Returns the shape of the tomogram without having to load it using the annotations attatched to this tomogram, if any are AnnotationFiles. If no AnnotationFiles of `.mod` type are in self.annotations, raises an exception. Returns: The shape of the tomogram as inferred from self.annotations. Raises: Exception: If no AnnotationFile objects are in self.annotations. Exception: If there are multiple AnnotationFile objects in self.annotations and they imply inconsistent shapes. \"\"\" shapes = [] for annotation in self . annotations : if isinstance ( annotation , AnnotationFile ) and annotation . extension == \".mod\" : shape = annotation . tomogram_shape_from_mod () shapes . append ( shape ) if len ( shapes ) == 0 : raise Exception ( \"No .mod annotations found. Cannot infer tomogram shape.\" ) elif len ( shapes ) == 1 : return shapes [ 0 ] else : # Confirm that all the shapes agree shape = shapes [ 0 ] for s in shapes [ 1 :]: if s != shape : raise Exception ( f \"Inconsistent tomogram shapes of { shape } and { s } implied by .mod annotations.\" ) return shape get_voxel_spacing () Uses .mrc file header information to find the voxel spacing of this tomogram in \u00c5ngstroms. Returns: \u2013 Either an integer (if the voxel spacing is isotropic, i.e., the same \u2013 in all directions), or a 3-tuple (if the spacing is anisotropic) \u2013 representing the voxel spacing in each direction. Raises: IOError \u2013 If the file type is not .mrc . Source code in tomogram_datasets/tomogram.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def get_voxel_spacing ( self ): \"\"\" Uses `.mrc` file header information to find the voxel spacing of this tomogram in \u00c5ngstroms. Returns: Either an integer (if the voxel spacing is isotropic, i.e., the same in all directions), or a 3-tuple (if the spacing is anisotropic) representing the voxel spacing in each direction. Raises: IOError: If the file type is not `.mrc`. \"\"\" # Determine file extension. root , extension = os . path . splitext ( self . filepath ) if extension not in [ \".mrc\" , \".rec\" ]: raise IOError ( \"Tomogram file must be .mrc to load the voxel spacing.\" ) mrc = mrcfile . open ( self . filepath , mode = 'r' , header_only = True ) spacing = mrc . voxel_size # Convert pesky np.recarray to a normal ndarray if isinstance ( spacing , np . recarray ): spacing = np . array ([ spacing . x . item (), spacing . y . item (), spacing . z . item ()]) # If the spacing is already a scalar, return it. if isinstance ( spacing , ( int , float )): return spacing # If it isn't, check if all the tuple values are the same. # If so, just return one. If not, return the whole tuple if spacing [ 0 ] == spacing [ 1 ] and spacing [ 0 ] == spacing [ 2 ]: return spacing [ 0 ] else : return spacing load ( * , preprocess = True ) Load the tomogram data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Parameters: preprocess ( bool , default: True ) \u2013 Whether to preprocess the data after loading. Defaults to True. Returns: \u2013 The loaded tomogram data. Raises: IOError \u2013 If the file type is not supported. Source code in tomogram_datasets/tomogram.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def load ( self , * , preprocess : bool = True ): \"\"\"Load the tomogram data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The loaded tomogram data. Raises: IOError: If the file type is not supported. \"\"\" if self . data is not None : return self . data # Determine how to load based on file extension. root , extension = os . path . splitext ( self . filepath ) if extension in [ \".mrc\" , \".rec\" ]: data = TomogramFile . mrc_to_np ( self . filepath ) elif extension == \".npy\" : data = np . load ( self . filepath ) else : raise IOError ( \"Tomogram file must be of type .mrc, .rec, or .npy.\" ) # Initialize Tomogram class super () . __init__ ( data , self . annotations ) if preprocess : self . process () return self . data load_header () Loads only tomogram header data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Returns: Union [ dict , recarray ] \u2013 The loaded tomogram header data. Raises: IOError \u2013 If the file type is not supported. Source code in tomogram_datasets/tomogram.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def load_header ( self ) -> Union [ dict , np . recarray ]: \"\"\"Loads only tomogram header data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Returns: The loaded tomogram header data. Raises: IOError: If the file type is not supported. \"\"\" # Determine how to load based on file extension. root , extension = os . path . splitext ( self . filepath ) if extension in [ \".mrc\" , \".rec\" ]: mrc = mrcfile . open ( self . filepath , header_only = True ) self . header = mrc . header # Shape seems backward because python convention is reverse of # FORTRAN convention. This is deliberate. self . shape = tuple ( self . header [ dim ] . item () for dim in [ 'nz' , 'ny' , 'nx' ]) mrc . close () elif extension == \".npy\" : self . header = dict () else : raise IOError ( \"Tomogram file must be of type .mrc, .rec, or .npy.\" ) return self . header mrc_to_np ( filepath ) staticmethod Convert a .mrc or .rec file to a numpy array. Parameters: filepath ( str ) \u2013 The file path to the .mrc or .rec file. Returns: ndarray \u2013 The data loaded as a numpy array. Source code in tomogram_datasets/tomogram.py 271 272 273 274 275 276 277 278 279 280 281 282 283 @staticmethod def mrc_to_np ( filepath : str ) -> np . ndarray : \"\"\"Convert a .mrc or .rec file to a numpy array. Args: filepath (str): The file path to the .mrc or .rec file. Returns: The data loaded as a numpy array. \"\"\" with mrcfile . open ( filepath , 'r' ) as mrc : data = mrc . data . astype ( np . float64 ) return data process () Process the tomogram to improve contrast using contrast stretching. This method applies contrast stretching to enhance the visibility of features in the tomogram. Returns: ndarray \u2013 The processed tomogram data. Source code in tomogram_datasets/tomogram.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 def process ( self ) -> np . ndarray : \"\"\"Process the tomogram to improve contrast using contrast stretching. This method applies contrast stretching to enhance the visibility of features in the tomogram. Returns: The processed tomogram data. \"\"\" # Contrast stretching p2 , p98 = np . percentile ( self . get_data (), ( 2 , 98 )) data_rescale = exposure . rescale_intensity ( self . get_data (), in_range = ( p2 , p98 )) self . data = data_rescale return self . get_data () reload () Reload the tomogram data from the file. This method reinitializes the tomogram data by loading it again from the specified file. If the data has already been loaded, access it with self.get_data(). Returns: ndarray \u2013 The reloaded tomogram data. Source code in tomogram_datasets/tomogram.py 300 301 302 303 304 305 306 307 308 309 310 311 def reload ( self ) -> np . ndarray : \"\"\"Reload the tomogram data from the file. This method reinitializes the tomogram data by loading it again from the specified file. If the data has already been loaded, access it with self.get_data(). Returns: The reloaded tomogram data. \"\"\" self . data = TomogramFile . mrc_to_np ( self . filepath ) return self . get_data () rescale ( array ) staticmethod Rescale array values to the range [0, 1]. Parameters: array ( ndarray ) \u2013 The array to be rescaled. Returns: ndarray \u2013 The rescaled array. Source code in tomogram_datasets/tomogram.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 @staticmethod def rescale ( array : np . ndarray ) -> np . ndarray : \"\"\"Rescale array values to the range [0, 1]. Args: array (numpy.ndarray): The array to be rescaled. Returns: The rescaled array. \"\"\" maximum = np . max ( array ) minimum = np . min ( array ) range_ = maximum - minimum return ( array - minimum ) / range_","title":"Tomograms"},{"location":"tomogram/#tomograms","text":"tomogram_datasets has two classes to represent a tomogram\u2014 Tomogram and TomogramFile , which is a specific kind of tomogram that comes from a file. One can load a tomogram from its filepath with tomogram = tomogram_datasets.Tomogram(filepath) , and get the tomogram's array data with tomogram.get_data() . Tomograms are often associated with Annotations in the Tomogram.annotations attribute. See more details below.","title":"Tomograms"},{"location":"tomogram/#tomogram_datasets.tomogram.Tomogram","text":"Represents a tomogram. Has fields for tomogram data and shape, as well as any annotations corresponding to the tomogram, which are represented with the Annotation class. Attributes: annotations ( list of Annotation ) \u2013 Annotations corresponding to this tomogram. data ( ndarray ) \u2013 A 3-dimensional array containing the tomogram image. shape ( ndarray ) \u2013 A 3-element array representing the shape of the tomogram data. Source code in tomogram_datasets/tomogram.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 class Tomogram : \"\"\"Represents a tomogram. Has fields for tomogram data and shape, as well as any annotations corresponding to the tomogram, which are represented with the Annotation class. Attributes: annotations (list of Annotation): Annotations corresponding to this tomogram. data (numpy.ndarray): A 3-dimensional array containing the tomogram image. shape (numpy.ndarray): A 3-element array representing the shape of the tomogram data. \"\"\" def __init__ ( self , data : np . ndarray , annotations : Optional [ List [ Annotation ]] = None ): \"\"\"Initialize a Tomogram instance. Args: data (numpy.ndarray): A 3-dimensional array containing the tomogram image. annotations (list of Annotation, optional): A list of annotations corresponding to the tomogram. Defaults to None. \"\"\" self . annotations = [] if annotations is None else annotations self . data = data self . shape = data . shape def add_annotation ( self , annotation : Annotation ): \"\"\"Add an annotation to the tomogram. Args: annotation (Annotation): An annotation object to be added to the tomogram's annotations. \"\"\" self . annotations . append ( annotation ) def annotation_points ( self , annotation_index : Optional [ int ] = None ): \"\"\"Get annotation points from the tomogram. Retrieves annotation points from a specific annotation if an index is provided, or all annotation points from all annotations if no index is given. Args: annotation_index (int, optional): The index of the annotation from which to retrieve points. If None, retrieves points from all annotations. Defaults to None. Returns: A list of points from the specified annotation or all annotations. \"\"\" if annotation_index is not None : return self . annotations [ annotation_index ] . points else : indices = range ( len ( self . annotations )) points = [] for index in indices : points += self . annotation_points ( index ) return points def get_data ( self ) -> np . ndarray : \"\"\"Access the data array in the tomogram. Returns: The array data of the tomogram. In other words, returns the image. \"\"\" return self . data","title":"Tomogram"},{"location":"tomogram/#tomogram_datasets.tomogram.Tomogram.__init__","text":"Initialize a Tomogram instance. Parameters: data ( ndarray ) \u2013 A 3-dimensional array containing the tomogram image. annotations ( list of Annotation , default: None ) \u2013 A list of annotations corresponding to the tomogram. Defaults to None. Source code in tomogram_datasets/tomogram.py 29 30 31 32 33 34 35 36 37 38 39 def __init__ ( self , data : np . ndarray , annotations : Optional [ List [ Annotation ]] = None ): \"\"\"Initialize a Tomogram instance. Args: data (numpy.ndarray): A 3-dimensional array containing the tomogram image. annotations (list of Annotation, optional): A list of annotations corresponding to the tomogram. Defaults to None. \"\"\" self . annotations = [] if annotations is None else annotations self . data = data self . shape = data . shape","title":"__init__"},{"location":"tomogram/#tomogram_datasets.tomogram.Tomogram.add_annotation","text":"Add an annotation to the tomogram. Parameters: annotation ( Annotation ) \u2013 An annotation object to be added to the tomogram's annotations. Source code in tomogram_datasets/tomogram.py 41 42 43 44 45 46 47 48 def add_annotation ( self , annotation : Annotation ): \"\"\"Add an annotation to the tomogram. Args: annotation (Annotation): An annotation object to be added to the tomogram's annotations. \"\"\" self . annotations . append ( annotation )","title":"add_annotation"},{"location":"tomogram/#tomogram_datasets.tomogram.Tomogram.annotation_points","text":"Get annotation points from the tomogram. Retrieves annotation points from a specific annotation if an index is provided, or all annotation points from all annotations if no index is given. Parameters: annotation_index ( int , default: None ) \u2013 The index of the annotation from which to retrieve points. If None, retrieves points from all annotations. Defaults to None. Returns: \u2013 A list of points from the specified annotation or all annotations. Source code in tomogram_datasets/tomogram.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def annotation_points ( self , annotation_index : Optional [ int ] = None ): \"\"\"Get annotation points from the tomogram. Retrieves annotation points from a specific annotation if an index is provided, or all annotation points from all annotations if no index is given. Args: annotation_index (int, optional): The index of the annotation from which to retrieve points. If None, retrieves points from all annotations. Defaults to None. Returns: A list of points from the specified annotation or all annotations. \"\"\" if annotation_index is not None : return self . annotations [ annotation_index ] . points else : indices = range ( len ( self . annotations )) points = [] for index in indices : points += self . annotation_points ( index ) return points","title":"annotation_points"},{"location":"tomogram/#tomogram_datasets.tomogram.Tomogram.get_data","text":"Access the data array in the tomogram. Returns: ndarray \u2013 The array data of the tomogram. In other words, returns the image. Source code in tomogram_datasets/tomogram.py 75 76 77 78 79 80 81 def get_data ( self ) -> np . ndarray : \"\"\"Access the data array in the tomogram. Returns: The array data of the tomogram. In other words, returns the image. \"\"\" return self . data","title":"get_data"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile","text":"Bases: Tomogram Represents a tomogram file. Extends the Tomogram class to handle file operations, including loading tomogram data from files of specific formats. Access the image data inside with get_data() . Attributes: filepath ( str ) \u2013 The file path to the tomogram file. annotations ( list of Annotation ) \u2013 Annotations corresponding to the tomogram. data ( ndarray ) \u2013 A 3-dimensional array containing the tomogram image. Source code in tomogram_datasets/tomogram.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 class TomogramFile ( Tomogram ): \"\"\"Represents a tomogram file. Extends the Tomogram class to handle file operations, including loading tomogram data from files of specific formats. Access the image data inside with `get_data()`. Attributes: filepath (str): The file path to the tomogram file. annotations (list of Annotation): Annotations corresponding to the tomogram. data (numpy.ndarray): A 3-dimensional array containing the tomogram image. header (dict or numpy.recarray) Other data related to the tomogram file. \"\"\" def __init__ ( self , filepath : str , annotations : Optional [ List [ Annotation ]] = None , * , load : bool = True ): \"\"\"Initialize a TomogramFile instance. Args: filepath (str): The file path to the tomogram file. annotations (list of Annotation, optional): Annotations corresponding to the tomogram. Defaults to None. load (bool, optional): Whether to load tomogram array data immediately. Defaults to True. If False, use self.load() when ready to load data. \"\"\" self . data = None self . annotations = annotations self . filepath = filepath self . load_header () if load : self . load () def load ( self , * , preprocess : bool = True ): \"\"\"Load the tomogram data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The loaded tomogram data. Raises: IOError: If the file type is not supported. \"\"\" if self . data is not None : return self . data # Determine how to load based on file extension. root , extension = os . path . splitext ( self . filepath ) if extension in [ \".mrc\" , \".rec\" ]: data = TomogramFile . mrc_to_np ( self . filepath ) elif extension == \".npy\" : data = np . load ( self . filepath ) else : raise IOError ( \"Tomogram file must be of type .mrc, .rec, or .npy.\" ) # Initialize Tomogram class super () . __init__ ( data , self . annotations ) if preprocess : self . process () return self . data def load_header ( self ) -> Union [ dict , np . recarray ]: \"\"\"Loads only tomogram header data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Returns: The loaded tomogram header data. Raises: IOError: If the file type is not supported. \"\"\" # Determine how to load based on file extension. root , extension = os . path . splitext ( self . filepath ) if extension in [ \".mrc\" , \".rec\" ]: mrc = mrcfile . open ( self . filepath , header_only = True ) self . header = mrc . header # Shape seems backward because python convention is reverse of # FORTRAN convention. This is deliberate. self . shape = tuple ( self . header [ dim ] . item () for dim in [ 'nz' , 'ny' , 'nx' ]) mrc . close () elif extension == \".npy\" : self . header = dict () else : raise IOError ( \"Tomogram file must be of type .mrc, .rec, or .npy.\" ) return self . header def get_data ( self , * , preprocess : bool = True ) -> np . ndarray : \"\"\" Access the data array in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The array data of the tomogram. In other words, returns the image. \"\"\" return self . load ( preprocess = preprocess ) def get_shape ( self , * , preprocess : bool = True ) -> np . ndarray : \"\"\" Access the data array shape in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array shape. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The data array shape of the tomogram. In other words, returns the image's dimensions. \"\"\" return self . shape def get_voxel_spacing ( self ): \"\"\" Uses `.mrc` file header information to find the voxel spacing of this tomogram in \u00c5ngstroms. Returns: Either an integer (if the voxel spacing is isotropic, i.e., the same in all directions), or a 3-tuple (if the spacing is anisotropic) representing the voxel spacing in each direction. Raises: IOError: If the file type is not `.mrc`. \"\"\" # Determine file extension. root , extension = os . path . splitext ( self . filepath ) if extension not in [ \".mrc\" , \".rec\" ]: raise IOError ( \"Tomogram file must be .mrc to load the voxel spacing.\" ) mrc = mrcfile . open ( self . filepath , mode = 'r' , header_only = True ) spacing = mrc . voxel_size # Convert pesky np.recarray to a normal ndarray if isinstance ( spacing , np . recarray ): spacing = np . array ([ spacing . x . item (), spacing . y . item (), spacing . z . item ()]) # If the spacing is already a scalar, return it. if isinstance ( spacing , ( int , float )): return spacing # If it isn't, check if all the tuple values are the same. # If so, just return one. If not, return the whole tuple if spacing [ 0 ] == spacing [ 1 ] and spacing [ 0 ] == spacing [ 2 ]: return spacing [ 0 ] else : return spacing @staticmethod def rescale ( array : np . ndarray ) -> np . ndarray : \"\"\"Rescale array values to the range [0, 1]. Args: array (numpy.ndarray): The array to be rescaled. Returns: The rescaled array. \"\"\" maximum = np . max ( array ) minimum = np . min ( array ) range_ = maximum - minimum return ( array - minimum ) / range_ @staticmethod def mrc_to_np ( filepath : str ) -> np . ndarray : \"\"\"Convert a .mrc or .rec file to a numpy array. Args: filepath (str): The file path to the .mrc or .rec file. Returns: The data loaded as a numpy array. \"\"\" with mrcfile . open ( filepath , 'r' ) as mrc : data = mrc . data . astype ( np . float64 ) return data def process ( self ) -> np . ndarray : \"\"\"Process the tomogram to improve contrast using contrast stretching. This method applies contrast stretching to enhance the visibility of features in the tomogram. Returns: The processed tomogram data. \"\"\" # Contrast stretching p2 , p98 = np . percentile ( self . get_data (), ( 2 , 98 )) data_rescale = exposure . rescale_intensity ( self . get_data (), in_range = ( p2 , p98 )) self . data = data_rescale return self . get_data () def reload ( self ) -> np . ndarray : \"\"\"Reload the tomogram data from the file. This method reinitializes the tomogram data by loading it again from the specified file. If the data has already been loaded, access it with self.get_data(). Returns: The reloaded tomogram data. \"\"\" self . data = TomogramFile . mrc_to_np ( self . filepath ) return self . get_data () def get_shape_from_annotations ( self ) -> np . ndarray : \"\"\" Returns the shape of the tomogram without having to load it using the annotations attatched to this tomogram, if any are AnnotationFiles. If no AnnotationFiles of `.mod` type are in self.annotations, raises an exception. Returns: The shape of the tomogram as inferred from self.annotations. Raises: Exception: If no AnnotationFile objects are in self.annotations. Exception: If there are multiple AnnotationFile objects in self.annotations and they imply inconsistent shapes. \"\"\" shapes = [] for annotation in self . annotations : if isinstance ( annotation , AnnotationFile ) and annotation . extension == \".mod\" : shape = annotation . tomogram_shape_from_mod () shapes . append ( shape ) if len ( shapes ) == 0 : raise Exception ( \"No .mod annotations found. Cannot infer tomogram shape.\" ) elif len ( shapes ) == 1 : return shapes [ 0 ] else : # Confirm that all the shapes agree shape = shapes [ 0 ] for s in shapes [ 1 :]: if s != shape : raise Exception ( f \"Inconsistent tomogram shapes of { shape } and { s } implied by .mod annotations.\" ) return shape","title":"TomogramFile"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.__init__","text":"Initialize a TomogramFile instance. Parameters: filepath ( str ) \u2013 The file path to the tomogram file. annotations ( list of Annotation , default: None ) \u2013 Annotations corresponding to the tomogram. Defaults to None. load ( bool , default: True ) \u2013 Whether to load tomogram array data immediately. Defaults to True. If False, use self.load() when ready to load data. Source code in tomogram_datasets/tomogram.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def __init__ ( self , filepath : str , annotations : Optional [ List [ Annotation ]] = None , * , load : bool = True ): \"\"\"Initialize a TomogramFile instance. Args: filepath (str): The file path to the tomogram file. annotations (list of Annotation, optional): Annotations corresponding to the tomogram. Defaults to None. load (bool, optional): Whether to load tomogram array data immediately. Defaults to True. If False, use self.load() when ready to load data. \"\"\" self . data = None self . annotations = annotations self . filepath = filepath self . load_header () if load : self . load ()","title":"__init__"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.get_data","text":"Access the data array in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array. Parameters: preprocess ( bool , default: True ) \u2013 Whether to preprocess the data after loading. Defaults to True. Returns: ndarray \u2013 The array data of the tomogram. In other words, returns the image. Source code in tomogram_datasets/tomogram.py 191 192 193 194 195 196 197 198 199 200 201 202 203 def get_data ( self , * , preprocess : bool = True ) -> np . ndarray : \"\"\" Access the data array in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The array data of the tomogram. In other words, returns the image. \"\"\" return self . load ( preprocess = preprocess )","title":"get_data"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.get_shape","text":"Access the data array shape in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array shape. Parameters: preprocess ( bool , default: True ) \u2013 Whether to preprocess the data after loading. Defaults to True. Returns: ndarray \u2013 The data array shape of the tomogram. In other words, returns the ndarray \u2013 image's dimensions. Source code in tomogram_datasets/tomogram.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def get_shape ( self , * , preprocess : bool = True ) -> np . ndarray : \"\"\" Access the data array shape in the tomogram. If the data has not been loaded, this method loads it and then returns the loaded array shape. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The data array shape of the tomogram. In other words, returns the image's dimensions. \"\"\" return self . shape","title":"get_shape"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.get_shape_from_annotations","text":"Returns the shape of the tomogram without having to load it using the annotations attatched to this tomogram, if any are AnnotationFiles. If no AnnotationFiles of .mod type are in self.annotations, raises an exception. Returns: ndarray \u2013 The shape of the tomogram as inferred from ndarray \u2013 self.annotations. Raises: Exception \u2013 If no AnnotationFile objects are in self.annotations. Exception \u2013 If there are multiple AnnotationFile objects in Source code in tomogram_datasets/tomogram.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 def get_shape_from_annotations ( self ) -> np . ndarray : \"\"\" Returns the shape of the tomogram without having to load it using the annotations attatched to this tomogram, if any are AnnotationFiles. If no AnnotationFiles of `.mod` type are in self.annotations, raises an exception. Returns: The shape of the tomogram as inferred from self.annotations. Raises: Exception: If no AnnotationFile objects are in self.annotations. Exception: If there are multiple AnnotationFile objects in self.annotations and they imply inconsistent shapes. \"\"\" shapes = [] for annotation in self . annotations : if isinstance ( annotation , AnnotationFile ) and annotation . extension == \".mod\" : shape = annotation . tomogram_shape_from_mod () shapes . append ( shape ) if len ( shapes ) == 0 : raise Exception ( \"No .mod annotations found. Cannot infer tomogram shape.\" ) elif len ( shapes ) == 1 : return shapes [ 0 ] else : # Confirm that all the shapes agree shape = shapes [ 0 ] for s in shapes [ 1 :]: if s != shape : raise Exception ( f \"Inconsistent tomogram shapes of { shape } and { s } implied by .mod annotations.\" ) return shape","title":"get_shape_from_annotations"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.get_voxel_spacing","text":"Uses .mrc file header information to find the voxel spacing of this tomogram in \u00c5ngstroms. Returns: \u2013 Either an integer (if the voxel spacing is isotropic, i.e., the same \u2013 in all directions), or a 3-tuple (if the spacing is anisotropic) \u2013 representing the voxel spacing in each direction. Raises: IOError \u2013 If the file type is not .mrc . Source code in tomogram_datasets/tomogram.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def get_voxel_spacing ( self ): \"\"\" Uses `.mrc` file header information to find the voxel spacing of this tomogram in \u00c5ngstroms. Returns: Either an integer (if the voxel spacing is isotropic, i.e., the same in all directions), or a 3-tuple (if the spacing is anisotropic) representing the voxel spacing in each direction. Raises: IOError: If the file type is not `.mrc`. \"\"\" # Determine file extension. root , extension = os . path . splitext ( self . filepath ) if extension not in [ \".mrc\" , \".rec\" ]: raise IOError ( \"Tomogram file must be .mrc to load the voxel spacing.\" ) mrc = mrcfile . open ( self . filepath , mode = 'r' , header_only = True ) spacing = mrc . voxel_size # Convert pesky np.recarray to a normal ndarray if isinstance ( spacing , np . recarray ): spacing = np . array ([ spacing . x . item (), spacing . y . item (), spacing . z . item ()]) # If the spacing is already a scalar, return it. if isinstance ( spacing , ( int , float )): return spacing # If it isn't, check if all the tuple values are the same. # If so, just return one. If not, return the whole tuple if spacing [ 0 ] == spacing [ 1 ] and spacing [ 0 ] == spacing [ 2 ]: return spacing [ 0 ] else : return spacing","title":"get_voxel_spacing"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.load","text":"Load the tomogram data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Parameters: preprocess ( bool , default: True ) \u2013 Whether to preprocess the data after loading. Defaults to True. Returns: \u2013 The loaded tomogram data. Raises: IOError \u2013 If the file type is not supported. Source code in tomogram_datasets/tomogram.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def load ( self , * , preprocess : bool = True ): \"\"\"Load the tomogram data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Args: preprocess (bool, optional): Whether to preprocess the data after loading. Defaults to True. Returns: The loaded tomogram data. Raises: IOError: If the file type is not supported. \"\"\" if self . data is not None : return self . data # Determine how to load based on file extension. root , extension = os . path . splitext ( self . filepath ) if extension in [ \".mrc\" , \".rec\" ]: data = TomogramFile . mrc_to_np ( self . filepath ) elif extension == \".npy\" : data = np . load ( self . filepath ) else : raise IOError ( \"Tomogram file must be of type .mrc, .rec, or .npy.\" ) # Initialize Tomogram class super () . __init__ ( data , self . annotations ) if preprocess : self . process () return self . data","title":"load"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.load_header","text":"Loads only tomogram header data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Returns: Union [ dict , recarray ] \u2013 The loaded tomogram header data. Raises: IOError \u2013 If the file type is not supported. Source code in tomogram_datasets/tomogram.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def load_header ( self ) -> Union [ dict , np . recarray ]: \"\"\"Loads only tomogram header data from the specified file. This method determines the file type based on its extension and loads the data accordingly. Returns: The loaded tomogram header data. Raises: IOError: If the file type is not supported. \"\"\" # Determine how to load based on file extension. root , extension = os . path . splitext ( self . filepath ) if extension in [ \".mrc\" , \".rec\" ]: mrc = mrcfile . open ( self . filepath , header_only = True ) self . header = mrc . header # Shape seems backward because python convention is reverse of # FORTRAN convention. This is deliberate. self . shape = tuple ( self . header [ dim ] . item () for dim in [ 'nz' , 'ny' , 'nx' ]) mrc . close () elif extension == \".npy\" : self . header = dict () else : raise IOError ( \"Tomogram file must be of type .mrc, .rec, or .npy.\" ) return self . header","title":"load_header"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.mrc_to_np","text":"Convert a .mrc or .rec file to a numpy array. Parameters: filepath ( str ) \u2013 The file path to the .mrc or .rec file. Returns: ndarray \u2013 The data loaded as a numpy array. Source code in tomogram_datasets/tomogram.py 271 272 273 274 275 276 277 278 279 280 281 282 283 @staticmethod def mrc_to_np ( filepath : str ) -> np . ndarray : \"\"\"Convert a .mrc or .rec file to a numpy array. Args: filepath (str): The file path to the .mrc or .rec file. Returns: The data loaded as a numpy array. \"\"\" with mrcfile . open ( filepath , 'r' ) as mrc : data = mrc . data . astype ( np . float64 ) return data","title":"mrc_to_np"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.process","text":"Process the tomogram to improve contrast using contrast stretching. This method applies contrast stretching to enhance the visibility of features in the tomogram. Returns: ndarray \u2013 The processed tomogram data. Source code in tomogram_datasets/tomogram.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 def process ( self ) -> np . ndarray : \"\"\"Process the tomogram to improve contrast using contrast stretching. This method applies contrast stretching to enhance the visibility of features in the tomogram. Returns: The processed tomogram data. \"\"\" # Contrast stretching p2 , p98 = np . percentile ( self . get_data (), ( 2 , 98 )) data_rescale = exposure . rescale_intensity ( self . get_data (), in_range = ( p2 , p98 )) self . data = data_rescale return self . get_data ()","title":"process"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.reload","text":"Reload the tomogram data from the file. This method reinitializes the tomogram data by loading it again from the specified file. If the data has already been loaded, access it with self.get_data(). Returns: ndarray \u2013 The reloaded tomogram data. Source code in tomogram_datasets/tomogram.py 300 301 302 303 304 305 306 307 308 309 310 311 def reload ( self ) -> np . ndarray : \"\"\"Reload the tomogram data from the file. This method reinitializes the tomogram data by loading it again from the specified file. If the data has already been loaded, access it with self.get_data(). Returns: The reloaded tomogram data. \"\"\" self . data = TomogramFile . mrc_to_np ( self . filepath ) return self . get_data ()","title":"reload"},{"location":"tomogram/#tomogram_datasets.tomogram.TomogramFile.rescale","text":"Rescale array values to the range [0, 1]. Parameters: array ( ndarray ) \u2013 The array to be rescaled. Returns: ndarray \u2013 The rescaled array. Source code in tomogram_datasets/tomogram.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 @staticmethod def rescale ( array : np . ndarray ) -> np . ndarray : \"\"\"Rescale array values to the range [0, 1]. Args: array (numpy.ndarray): The array to be rescaled. Returns: The rescaled array. \"\"\" maximum = np . max ( array ) minimum = np . min ( array ) range_ = maximum - minimum return ( array - minimum ) / range_","title":"rescale"}]}